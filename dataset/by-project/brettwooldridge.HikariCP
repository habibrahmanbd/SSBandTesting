[{"bugType": "DIFFERENT_METHOD_SAME_ARGS", "fixCommitSHA1": "14ceda3b0cb8b2055a05c6c6984aa785b8864563", "fixCommitParentSHA1": "4c2486e4a0a97e852d9901853b39a0ca81544543", "bugFilePath": "src/main/java/com/zaxxer/hikari/pool/PoolBase.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/pool/PoolBase.java b/src/main/java/com/zaxxer/hikari/pool/PoolBase.java\nindex fdd4057..ee5ca12 100644\n--- a/src/main/java/com/zaxxer/hikari/pool/PoolBase.java\n+++ b/src/main/java/com/zaxxer/hikari/pool/PoolBase.java\n@@ -363,7 +363,7 @@\n                connection.isValid(1);\n             }\n             catch (Throwable e) {\n-               LOGGER.warn(\"{} - Failed to execute isValid() for connection, configure connection test query. ({})\", poolName, e.getMessage());\n+               LOGGER.error(\"{} - Failed to execute isValid() for connection, configure connection test query. ({})\", poolName, e.getMessage());\n                throw e;\n             }\n          }\n@@ -372,7 +372,7 @@\n                executeSql(connection, config.getConnectionTestQuery(), false, isIsolateInternalQueries && !isAutoCommit);\n             }\n             catch (Throwable e) {\n-               LOGGER.warn(\"{} - Failed to execute connection test query. ({})\", poolName, e.getMessage());\n+               LOGGER.error(\"{} - Failed to execute connection test query. ({})\", poolName, e.getMessage());\n                throw e;\n             }\n          }\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 366, "bugNodeStartChar": 12718, "bugNodeLength": 127, "fixLineNum": 366, "fixNodeStartChar": 12718, "fixNodeLength": 128, "sourceBeforeFix": "LOGGER.warn(\"{} - Failed to execute isValid() for connection, configure connection test query. ({})\",poolName,e.getMessage())", "sourceAfterFix": "LOGGER.error(\"{} - Failed to execute isValid() for connection, configure connection test query. ({})\",poolName,e.getMessage())"}, {"bugType": "CHANGE_IDENTIFIER", "fixCommitSHA1": "14ceda3b0cb8b2055a05c6c6984aa785b8864563", "fixCommitParentSHA1": "4c2486e4a0a97e852d9901853b39a0ca81544543", "bugFilePath": "src/main/java/com/zaxxer/hikari/pool/PoolBase.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/pool/PoolBase.java b/src/main/java/com/zaxxer/hikari/pool/PoolBase.java\nindex fdd4057..ee5ca12 100644\n--- a/src/main/java/com/zaxxer/hikari/pool/PoolBase.java\n+++ b/src/main/java/com/zaxxer/hikari/pool/PoolBase.java\n@@ -363,7 +363,7 @@\n                connection.isValid(1);\n             }\n             catch (Throwable e) {\n-               LOGGER.warn(\"{} - Failed to execute isValid() for connection, configure connection test query. ({})\", poolName, e.getMessage());\n+               LOGGER.error(\"{} - Failed to execute isValid() for connection, configure connection test query. ({})\", poolName, e.getMessage());\n                throw e;\n             }\n          }\n@@ -372,7 +372,7 @@\n                executeSql(connection, config.getConnectionTestQuery(), false, isIsolateInternalQueries && !isAutoCommit);\n             }\n             catch (Throwable e) {\n-               LOGGER.warn(\"{} - Failed to execute connection test query. ({})\", poolName, e.getMessage());\n+               LOGGER.error(\"{} - Failed to execute connection test query. ({})\", poolName, e.getMessage());\n                throw e;\n             }\n          }\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 366, "bugNodeStartChar": 12718, "bugNodeLength": 127, "fixLineNum": 366, "fixNodeStartChar": 12718, "fixNodeLength": 128, "sourceBeforeFix": "LOGGER.warn(\"{} - Failed to execute isValid() for connection, configure connection test query. ({})\",poolName,e.getMessage())", "sourceAfterFix": "LOGGER.error(\"{} - Failed to execute isValid() for connection, configure connection test query. ({})\",poolName,e.getMessage())"}, {"bugType": "DIFFERENT_METHOD_SAME_ARGS", "fixCommitSHA1": "14ceda3b0cb8b2055a05c6c6984aa785b8864563", "fixCommitParentSHA1": "4c2486e4a0a97e852d9901853b39a0ca81544543", "bugFilePath": "src/main/java/com/zaxxer/hikari/pool/PoolBase.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/pool/PoolBase.java b/src/main/java/com/zaxxer/hikari/pool/PoolBase.java\nindex fdd4057..ee5ca12 100644\n--- a/src/main/java/com/zaxxer/hikari/pool/PoolBase.java\n+++ b/src/main/java/com/zaxxer/hikari/pool/PoolBase.java\n@@ -363,7 +363,7 @@\n                connection.isValid(1);\n             }\n             catch (Throwable e) {\n-               LOGGER.warn(\"{} - Failed to execute isValid() for connection, configure connection test query. ({})\", poolName, e.getMessage());\n+               LOGGER.error(\"{} - Failed to execute isValid() for connection, configure connection test query. ({})\", poolName, e.getMessage());\n                throw e;\n             }\n          }\n@@ -372,7 +372,7 @@\n                executeSql(connection, config.getConnectionTestQuery(), false, isIsolateInternalQueries && !isAutoCommit);\n             }\n             catch (Throwable e) {\n-               LOGGER.warn(\"{} - Failed to execute connection test query. ({})\", poolName, e.getMessage());\n+               LOGGER.error(\"{} - Failed to execute connection test query. ({})\", poolName, e.getMessage());\n                throw e;\n             }\n          }\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 375, "bugNodeStartChar": 13115, "bugNodeLength": 91, "fixLineNum": 375, "fixNodeStartChar": 13115, "fixNodeLength": 92, "sourceBeforeFix": "LOGGER.warn(\"{} - Failed to execute connection test query. ({})\",poolName,e.getMessage())", "sourceAfterFix": "LOGGER.error(\"{} - Failed to execute connection test query. ({})\",poolName,e.getMessage())"}, {"bugType": "CHANGE_IDENTIFIER", "fixCommitSHA1": "14ceda3b0cb8b2055a05c6c6984aa785b8864563", "fixCommitParentSHA1": "4c2486e4a0a97e852d9901853b39a0ca81544543", "bugFilePath": "src/main/java/com/zaxxer/hikari/pool/PoolBase.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/pool/PoolBase.java b/src/main/java/com/zaxxer/hikari/pool/PoolBase.java\nindex fdd4057..ee5ca12 100644\n--- a/src/main/java/com/zaxxer/hikari/pool/PoolBase.java\n+++ b/src/main/java/com/zaxxer/hikari/pool/PoolBase.java\n@@ -363,7 +363,7 @@\n                connection.isValid(1);\n             }\n             catch (Throwable e) {\n-               LOGGER.warn(\"{} - Failed to execute isValid() for connection, configure connection test query. ({})\", poolName, e.getMessage());\n+               LOGGER.error(\"{} - Failed to execute isValid() for connection, configure connection test query. ({})\", poolName, e.getMessage());\n                throw e;\n             }\n          }\n@@ -372,7 +372,7 @@\n                executeSql(connection, config.getConnectionTestQuery(), false, isIsolateInternalQueries && !isAutoCommit);\n             }\n             catch (Throwable e) {\n-               LOGGER.warn(\"{} - Failed to execute connection test query. ({})\", poolName, e.getMessage());\n+               LOGGER.error(\"{} - Failed to execute connection test query. ({})\", poolName, e.getMessage());\n                throw e;\n             }\n          }\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 375, "bugNodeStartChar": 13115, "bugNodeLength": 91, "fixLineNum": 375, "fixNodeStartChar": 13115, "fixNodeLength": 92, "sourceBeforeFix": "LOGGER.warn(\"{} - Failed to execute connection test query. ({})\",poolName,e.getMessage())", "sourceAfterFix": "LOGGER.error(\"{} - Failed to execute connection test query. ({})\",poolName,e.getMessage())"}, {"bugType": "CHANGE_NUMERAL", "fixCommitSHA1": "8eaaa7fdcddab9de44049a062f413533d2447f26", "fixCommitParentSHA1": "cfd5e4d054fe776cc72454bc5d46b71eabe7179c", "bugFilePath": "src/main/java/com/zaxxer/hikari/pool/HikariPool.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/pool/HikariPool.java b/src/main/java/com/zaxxer/hikari/pool/HikariPool.java\nindex 619ef20..3d7242f 100644\n--- a/src/main/java/com/zaxxer/hikari/pool/HikariPool.java\n+++ b/src/main/java/com/zaxxer/hikari/pool/HikariPool.java\n@@ -438,7 +438,7 @@\n          final long maxLifetime = config.getMaxLifetime();\n          if (maxLifetime > 0) {\n             // variance up to 2.5% of the maxlifetime\n-            final long variance = maxLifetime > 10_000 ? ThreadLocalRandom.current().nextLong( Math.max(10_000, maxLifetime / 40) ) : 0;\n+            final long variance = maxLifetime > 10_000 ? ThreadLocalRandom.current().nextLong( maxLifetime / 40 ) : 0;\n             final long lifetime = maxLifetime - variance;\n             poolEntry.setFutureEol(houseKeepingExecutorService.schedule(new Runnable() {\n                @Override\n@@ -573,7 +573,7 @@\n \n             // failed to get connection from db, sleep and retry\n             quietlySleep(sleepBackoff);\n-            sleepBackoff = Math.min(connectionTimeout / 2, (long) (sleepBackoff * 1.3));\n+            sleepBackoff = Math.min(connectionTimeout / 4, (long) (sleepBackoff * 1.3));\n          }\n          // Pool is suspended or shutdown or at max size\n          return Boolean.FALSE;\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 576, "bugNodeStartChar": 20791, "bugNodeLength": 21, "fixLineNum": 576, "fixNodeStartChar": 20791, "fixNodeLength": 21, "sourceBeforeFix": "connectionTimeout / 2", "sourceAfterFix": "connectionTimeout / 4"}, {"bugType": "OVERLOAD_METHOD_DELETED_ARGS", "fixCommitSHA1": "79386c6487a53eba8b6690e3d03b90eda0e2d842", "fixCommitParentSHA1": "b2cfd099988a9491b1fa0052ab32a0c05596698e", "bugFilePath": "src/main/java/com/zaxxer/hikari/pool/HikariPool.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/pool/HikariPool.java b/src/main/java/com/zaxxer/hikari/pool/HikariPool.java\nindex 19b49e7..3a87b7f 100644\n--- a/src/main/java/com/zaxxer/hikari/pool/HikariPool.java\n+++ b/src/main/java/com/zaxxer/hikari/pool/HikariPool.java\n@@ -167,7 +167,7 @@\n             final long now = clockSource.currentTime();\n             if (poolEntry.evict || (clockSource.elapsedMillis(poolEntry.lastAccessed, now) > ALIVE_BYPASS_WINDOW_MS && !isConnectionAlive(poolEntry.connection))) {\n                closeConnection(poolEntry, \"(connection evicted or dead)\"); // Throw away the dead connection and try again\n-               timeout = hardTimeout - clockSource.elapsedMillis(startTime, now);\n+               timeout = hardTimeout - clockSource.elapsedMillis(startTime);\n             }\n             else {\n                metricsTracker.recordBorrowStats(poolEntry, startTime);\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 170, "bugNodeStartChar": 7298, "bugNodeLength": 41, "fixLineNum": 170, "fixNodeStartChar": 7298, "fixNodeLength": 36, "sourceBeforeFix": "clockSource.elapsedMillis(startTime,now)", "sourceAfterFix": "clockSource.elapsedMillis(startTime)"}, {"bugType": "CHANGE_NUMERAL", "fixCommitSHA1": "b2cfd099988a9491b1fa0052ab32a0c05596698e", "fixCommitParentSHA1": "e125d509fea9b3d165aa68860c563918eb0e4233", "bugFilePath": "src/test/java/com/zaxxer/hikari/pool/TestConnectionTimeoutRetry.java", "fixPatch": "diff --git a/src/test/java/com/zaxxer/hikari/pool/TestConnectionTimeoutRetry.java b/src/test/java/com/zaxxer/hikari/pool/TestConnectionTimeoutRetry.java\nindex 0d5f009..c8c9d27 100644\n--- a/src/test/java/com/zaxxer/hikari/pool/TestConnectionTimeoutRetry.java\n+++ b/src/test/java/com/zaxxer/hikari/pool/TestConnectionTimeoutRetry.java\n@@ -234,7 +234,7 @@\n          Connection connection6 = ds.getConnection();\n          Connection connection7 = ds.getConnection();\n \n-         Thread.sleep(1200);\n+         Thread.sleep(2000);\n \n          Assert.assertSame(\"Totals connections not as expected\", 10, TestElf.getPool(ds).getTotalConnections());\n          Assert.assertSame(\"Idle connections not as expected\", 3, TestElf.getPool(ds).getIdleConnections());\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 237, "bugNodeStartChar": 8682, "bugNodeLength": 18, "fixLineNum": 237, "fixNodeStartChar": 8682, "fixNodeLength": 18, "sourceBeforeFix": "Thread.sleep(1200)", "sourceAfterFix": "Thread.sleep(2000)"}, {"bugType": "OVERLOAD_METHOD_MORE_ARGS", "fixCommitSHA1": "c1ee0b0ce8a20ea5096be3acff32446dbf4fc53f", "fixCommitParentSHA1": "2cf1446fdd266772cc1c24c3f3ec563b6b0c6f49", "bugFilePath": "src/main/java/com/zaxxer/hikari/pool/PoolElf.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/pool/PoolElf.java b/src/main/java/com/zaxxer/hikari/pool/PoolElf.java\nindex 76d72f2..6560a47 100644\n--- a/src/main/java/com/zaxxer/hikari/pool/PoolElf.java\n+++ b/src/main/java/com/zaxxer/hikari/pool/PoolElf.java\n@@ -175,7 +175,7 @@\n    void setupConnection(final Connection connection, final long connectionTimeout) throws SQLException\n    {\n       if (isUseJdbc4Validation && !isJdbc4ValidationSupported(connection)) {\n-         throw new SQLException(\"Connection.isValid() method is not supported, connection test query must be configured\");\n+         throw new SQLException(\"Connection.isValid() is not supported, configure connection test query.\");\n       }\n \n       networkTimeout = getAndSetNetworkTimeout(connection, connectionTimeout);\n@@ -269,7 +269,7 @@\n       }\n       \n       if (LOGGER.isDebugEnabled()) {\n-         LOGGER.debug(\"{} - Reset ({}) on connection {}\", resetBits != 0 ? stringFromResetBits(resetBits) : \"nothing\", poolEntry.connection);\n+         LOGGER.debug(\"{} - Reset ({}) on connection {}\", poolName, resetBits != 0 ? stringFromResetBits(resetBits) : \"nothing\", poolEntry.connection);\n       }\n    }\n \n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 272, "bugNodeStartChar": 9640, "bugNodeLength": 131, "fixLineNum": 272, "fixNodeStartChar": 9640, "fixNodeLength": 141, "sourceBeforeFix": "LOGGER.debug(\"{} - Reset ({}) on connection {}\",resetBits != 0 ? stringFromResetBits(resetBits) : \"nothing\",poolEntry.connection)", "sourceAfterFix": "LOGGER.debug(\"{} - Reset ({}) on connection {}\",poolName,resetBits != 0 ? stringFromResetBits(resetBits) : \"nothing\",poolEntry.connection)"}, {"bugType": "CHANGE_IDENTIFIER", "fixCommitSHA1": "31113bf0d908a8fc194f078dae57b81494db7126", "fixCommitParentSHA1": "0dbdc47f05c914a6437ab50ab19db5c2f0e61d5a", "bugFilePath": "src/test/java/com/zaxxer/hikari/TestValidation.java", "fixPatch": "diff --git a/src/test/java/com/zaxxer/hikari/TestValidation.java b/src/test/java/com/zaxxer/hikari/TestValidation.java\nindex e0c8207..a3c6536 100644\n--- a/src/test/java/com/zaxxer/hikari/TestValidation.java\n+++ b/src/test/java/com/zaxxer/hikari/TestValidation.java\n@@ -59,7 +59,7 @@\n          config.validate();\n          Assert.fail();\n       }\n-      catch (IllegalStateException ise) {\n+      catch (IllegalArgumentException ise) {\n          // pass\n       }\n    }\n@@ -183,7 +183,7 @@\n          config.validate();\n          Assert.fail();\n       }\n-      catch (IllegalStateException ise) {\n+      catch (IllegalArgumentException ise) {\n          Assert.assertTrue(ise.getMessage().contains(\"together\"));\n       }\n    }\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 62, "bugNodeStartChar": 1754, "bugNodeLength": 25, "fixLineNum": 62, "fixNodeStartChar": 1754, "fixNodeLength": 28, "sourceBeforeFix": "IllegalStateException ise", "sourceAfterFix": "IllegalArgumentException ise"}, {"bugType": "CHANGE_IDENTIFIER", "fixCommitSHA1": "31113bf0d908a8fc194f078dae57b81494db7126", "fixCommitParentSHA1": "0dbdc47f05c914a6437ab50ab19db5c2f0e61d5a", "bugFilePath": "src/test/java/com/zaxxer/hikari/TestValidation.java", "fixPatch": "diff --git a/src/test/java/com/zaxxer/hikari/TestValidation.java b/src/test/java/com/zaxxer/hikari/TestValidation.java\nindex e0c8207..a3c6536 100644\n--- a/src/test/java/com/zaxxer/hikari/TestValidation.java\n+++ b/src/test/java/com/zaxxer/hikari/TestValidation.java\n@@ -59,7 +59,7 @@\n          config.validate();\n          Assert.fail();\n       }\n-      catch (IllegalStateException ise) {\n+      catch (IllegalArgumentException ise) {\n          // pass\n       }\n    }\n@@ -183,7 +183,7 @@\n          config.validate();\n          Assert.fail();\n       }\n-      catch (IllegalStateException ise) {\n+      catch (IllegalArgumentException ise) {\n          Assert.assertTrue(ise.getMessage().contains(\"together\"));\n       }\n    }\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 186, "bugNodeStartChar": 5435, "bugNodeLength": 25, "fixLineNum": 186, "fixNodeStartChar": 5435, "fixNodeLength": 28, "sourceBeforeFix": "IllegalStateException ise", "sourceAfterFix": "IllegalArgumentException ise"}, {"bugType": "CHANGE_IDENTIFIER", "fixCommitSHA1": "60e0eb1b8bb87242665c37e1f3ecf549b2457206", "fixCommitParentSHA1": "7aa6870af06d990f53b00494258d2ead222aeb5a", "bugFilePath": "hikaricp-common/src/main/java/com/zaxxer/hikari/AbstractHikariConfig.java", "fixPatch": "diff --git a/hikaricp-common/src/main/java/com/zaxxer/hikari/AbstractHikariConfig.java b/hikaricp-common/src/main/java/com/zaxxer/hikari/AbstractHikariConfig.java\nindex 5471c83..c8dd612 100644\n--- a/hikaricp-common/src/main/java/com/zaxxer/hikari/AbstractHikariConfig.java\n+++ b/hikaricp-common/src/main/java/com/zaxxer/hikari/AbstractHikariConfig.java\n@@ -38,7 +38,7 @@\n import com.zaxxer.hikari.util.PropertyBeanSetter;\n import com.zaxxer.hikari.util.UtilityElf;\n \n-public abstract class AbstractHikariConfig implements HikariConfigMBean\n+public abstract class AbstractHikariConfig implements HikariConfigMXBean\n {\n    private static final Logger LOGGER = LoggerFactory.getLogger(HikariConfig.class);\n \n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 41, "bugNodeStartChar": 1273, "bugNodeLength": 23856, "fixLineNum": 41, "fixNodeStartChar": 1273, "fixNodeLength": 23857, "sourceBeforeFix": "public abstract class AbstractHikariConfig implements HikariConfigMBean {   private static final Logger LOGGER=LoggerFactory.getLogger(HikariConfig.class);   private static final long CONNECTION_TIMEOUT=TimeUnit.SECONDS.toMillis(30);   private static final long VALIDATION_TIMEOUT=TimeUnit.SECONDS.toMillis(5);   private static final long IDLE_TIMEOUT=TimeUnit.MINUTES.toMillis(10);   private static final long MAX_LIFETIME=TimeUnit.MINUTES.toMillis(30);   private static int poolNumber;   private static boolean unitTest;   private volatile long connectionTimeout;   private volatile long validationTimeout;   private volatile long idleTimeout;   private volatile long leakDetectionThreshold;   private volatile long maxLifetime;   private volatile int maxPoolSize;   private volatile int minIdle;   private String catalog;   private String connectionCustomizerClassName;   private String connectionInitSql;   private String connectionTestQuery;   private String dataSourceClassName;   private String dataSourceJndiName;   private String driverClassName;   private String jdbcUrl;   private String password;   private String poolName;   private String transactionIsolationName;   private String username;   private boolean isAutoCommit;   private boolean isReadOnly;   private boolean isInitializationFailFast;   private boolean isIsolateInternalQueries;   private boolean isRegisterMbeans;   private boolean isAllowPoolSuspension;   private DataSource dataSource;   private Properties dataSourceProperties;   private IConnectionCustomizer customizer;   private ThreadFactory threadFactory;   private Object metricRegistry;   private Object healthCheckRegistry;   private Properties healthCheckProperties;   /**   * Default constructor  */   public AbstractHikariConfig(){     dataSourceProperties=new Properties();     healthCheckProperties=new Properties();     connectionTimeout=CONNECTION_TIMEOUT;     validationTimeout=VALIDATION_TIMEOUT;     idleTimeout=IDLE_TIMEOUT;     isAutoCommit=true;     isInitializationFailFast=true;     minIdle=-1;     maxPoolSize=10;     maxLifetime=MAX_LIFETIME;     customizer=new IConnectionCustomizer(){       @Override public void customize(      Connection connection) throws SQLException {       }     } ;     String systemProp=System.getProperty(\"hikaricp.configurationFile\");     if (systemProp != null) {       loadProperties(systemProp);     }   }   /**   * Construct a HikariConfig from the specified properties object.  * @param properties the name of the property file  */   public AbstractHikariConfig(  Properties properties){     this();     PropertyBeanSetter.setTargetFromProperties(this,properties);   }   /**   * Construct a HikariConfig from the specified property file name.  <code>propertyFileName</code> will first be treated as a path in the file-system, and if that fails the  ClassLoader.getResourceAsStream(propertyFileName) will be tried.  * @param propertyFileName the name of the property file  */   public AbstractHikariConfig(  String propertyFileName){     this();     loadProperties(propertyFileName);   }   /**   * Get the default catalog name to be set on connections.  * @return the default catalog name  */   public String getCatalog(){     return catalog;   }   /**   * Set the default catalog name to be set on connections.  * @param catalog the catalog name, or null  */   public void setCatalog(  String catalog){     this.catalog=catalog;   }   /**   * Get the name of the connection customizer class to instantiate and execute on all new connections.  * @return the name of the customizer class, or null  */   @Deprecated public String getConnectionCustomizerClassName(){     return connectionCustomizerClassName;   }   /**   * Set the name of the connection customizer class to instantiate and execute on all new connections.  * @param connectionCustomizerClassName the name of the customizer class  */   @Deprecated public void setConnectionCustomizerClassName(  String connectionCustomizerClassName){     this.connectionCustomizerClassName=connectionCustomizerClassName;     LOGGER.warn(\"The connectionCustomizerClassName property has been deprecated and may be removed in a future release\");   }   /**   * Get the customizer instance specified by the user.  * @return an instance of IConnectionCustomizer  */   @Deprecated public IConnectionCustomizer getConnectionCustomizer(){     return customizer;   }   /**   * Set the connection customizer to be used by the pool.  * @param customizer an instance of IConnectionCustomizer  */   @Deprecated public void setConnectionCustomizer(  IConnectionCustomizer customizer){     this.customizer=customizer;     LOGGER.warn(\"The connectionCustomizer property has been deprecated and may be removed in a future release\");   }   /**   * Get the SQL query to be executed to test the validity of connections.  * @return the SQL query string, or null   */   public String getConnectionTestQuery(){     return connectionTestQuery;   }   /**   * Set the SQL query to be executed to test the validity of connections. Using the JDBC4 <code>Connection.isValid()</code> method to test connection validity can be more efficient on some databases and is recommended.  See  {@link HikariConfig#setJdbc4ConnectionTest(boolean)}.  * @param connectionTestQuery a SQL query string  */   public void setConnectionTestQuery(  String connectionTestQuery){     this.connectionTestQuery=connectionTestQuery;   }   /**   * Get the SQL string that will be executed on all new connections when they are created, before they are added to the pool.  * @return the SQL to execute on new connections, or null  */   public String getConnectionInitSql(){     return connectionInitSql;   }   /**   * Set the SQL string that will be executed on all new connections when they are created, before they are added to the pool.  If this query fails, it will be treated as a failed connection attempt.  * @param connectionInitSql the SQL to execute on new connections  */   public void setConnectionInitSql(  String connectionInitSql){     this.connectionInitSql=connectionInitSql;   }   /**   * {@inheritDoc}   */   @Override public long getConnectionTimeout(){     return connectionTimeout;   }   /**   * {@inheritDoc}   */   @Override public void setConnectionTimeout(  long connectionTimeoutMs){     if (connectionTimeoutMs == 0) {       this.connectionTimeout=Integer.MAX_VALUE;     }  else     if (connectionTimeoutMs < 1000) {       throw new IllegalArgumentException(\"connectionTimeout cannot be less than 1000ms\");     }  else {       this.connectionTimeout=connectionTimeoutMs;     }   }   /**   * {@inheritDoc}   */   @Override public long getValidationTimeout(){     return validationTimeout;   }   /**   * {@inheritDoc}   */   @Override public void setValidationTimeout(  long validationTimeoutMs){     if (validationTimeoutMs < 1000) {       throw new IllegalArgumentException(\"validationTimeout cannot be less than 1000ms\");     }  else {       this.validationTimeout=validationTimeoutMs;     }   }   /**   * Get the  {@link DataSource} that has been explicitly specified to be wrapped by thepool.  * @return the {@link DataSource} instance, or null  */   public DataSource getDataSource(){     return dataSource;   }   /**   * Set a  {@link DataSource} for the pool to explicitly wrap.  This setter is notavailable through property file based initialization.  * @param dataSource a specific {@link DataSource} to be wrapped by the pool  */   public void setDataSource(  DataSource dataSource){     this.dataSource=dataSource;   }   public String getDataSourceClassName(){     return dataSourceClassName;   }   public void setDataSourceClassName(  String className){     this.dataSourceClassName=className;   }   public void addDataSourceProperty(  String propertyName,  Object value){     dataSourceProperties.put(propertyName,value);   }   public String getDataSourceJNDI(){     return this.dataSourceJndiName;   }   public void setDataSourceJNDI(  String jndiDataSource){     this.dataSourceJndiName=jndiDataSource;   }   public Properties getDataSourceProperties(){     return dataSourceProperties;   }   public void setDataSourceProperties(  Properties dsProperties){     dataSourceProperties.putAll(dsProperties);   }   public String getDriverClassName(){     return driverClassName;   }   public void setDriverClassName(  String driverClassName){     try {       Class<?> driverClass=this.getClass().getClassLoader().loadClass(driverClassName);       driverClass.newInstance();       this.driverClassName=driverClassName;     }  catch (    Exception e) {       throw new RuntimeException(\"driverClassName specified class '\" + driverClassName + \"' could not be loaded\",e);     }   }   /**   * {@inheritDoc}   */   @Override public long getIdleTimeout(){     return idleTimeout;   }   /**   * {@inheritDoc}   */   @Override public void setIdleTimeout(  long idleTimeoutMs){     if (idleTimeoutMs < 0) {       throw new IllegalArgumentException(\"idleTimeout cannot be negative\");     }     this.idleTimeout=idleTimeoutMs;   }   public String getJdbcUrl(){     return jdbcUrl;   }   public void setJdbcUrl(  String jdbcUrl){     this.jdbcUrl=jdbcUrl;   }   /**   * Get the default auto-commit behavior of connections in the pool.  * @return the default auto-commit behavior of connections  */   public boolean isAutoCommit(){     return isAutoCommit;   }   /**   * Set the default auto-commit behavior of connections in the pool.  * @param isAutoCommit the desired auto-commit default for connections  */   public void setAutoCommit(  boolean isAutoCommit){     this.isAutoCommit=isAutoCommit;   }   /**   * Get the pool suspension behavior (allowed or disallowed).  * @return the pool suspension behavior  */   public boolean isAllowPoolSuspension(){     return isAllowPoolSuspension;   }   /**   * Set whether or not pool suspension is allowed.  There is a performance impact when pool suspension is enabled.  Unless you need it (for a redundancy system for example) do not enable it.  * @param isAllowPoolSuspension the desired pool suspension allowance  */   public void setAllowPoolSuspension(  boolean isAllowPoolSuspension){     this.isAllowPoolSuspension=isAllowPoolSuspension;   }   /**   * Get whether or not the construction of the pool should throw an exception if the minimum number of connections cannot be created.  * @return whether or not initialization should fail on error immediately  */   public boolean isInitializationFailFast(){     return isInitializationFailFast;   }   /**   * Set whether or not the construction of the pool should throw an exception if the minimum number of connections cannot be created.  * @param failFast true if the pool should fail if the minimum connections cannot be created  */   public void setInitializationFailFast(  boolean failFast){     isInitializationFailFast=failFast;   }   public boolean isIsolateInternalQueries(){     return isIsolateInternalQueries;   }   public void setIsolateInternalQueries(  boolean isolate){     this.isIsolateInternalQueries=isolate;   }   @Deprecated public boolean isJdbc4ConnectionTest(){     return false;   }   @Deprecated public void setJdbc4ConnectionTest(  boolean useIsValid){     LOGGER.warn(\"The jdbcConnectionTest property is now deprecated, see the documentation for connectionTestQuery\");   }   /**   * Get the Codahale MetricRegistry, could be null.  * @return the codahale MetricRegistry instance  */   public Object getMetricRegistry(){     return metricRegistry;   }   /**   * Set a Codahale MetricRegistry to use for HikariCP.  * @param metricRegistry the Codahale MetricRegistry to set  */   public void setMetricRegistry(  Object metricRegistry){     if (metricRegistry != null) {       if (metricRegistry instanceof String) {         try {           InitialContext initCtx=new InitialContext();           metricRegistry=(MetricRegistry)initCtx.lookup((String)metricRegistry);         }  catch (        NamingException e) {           throw new IllegalArgumentException(e);         }       }       if (!(metricRegistry instanceof MetricRegistry)) {         throw new IllegalArgumentException(\"Class must be an instance of com.codahale.metrics.MetricRegistry\");       }     }     this.metricRegistry=metricRegistry;   }   /**   * Get the Codahale HealthCheckRegistry, could be null.  * @return the Codahale HealthCheckRegistry instance  */   public Object getHealthCheckRegistry(){     return healthCheckRegistry;   }   /**   * Set a Codahale HealthCheckRegistry to use for HikariCP.  * @param healthCheckRegistry the Codahale HealthCheckRegistry to set  */   public void setHealthCheckRegistry(  Object healthCheckRegistry){     if (healthCheckRegistry != null) {       if (healthCheckRegistry instanceof String) {         try {           InitialContext initCtx=new InitialContext();           healthCheckRegistry=(HealthCheckRegistry)initCtx.lookup((String)healthCheckRegistry);         }  catch (        NamingException e) {           throw new IllegalArgumentException(e);         }       }       if (!(healthCheckRegistry instanceof HealthCheckRegistry)) {         throw new IllegalArgumentException(\"Class must be an instance of com.codahale.metrics.health.HealthCheckRegistry\");       }     }     this.healthCheckRegistry=healthCheckRegistry;   }   public Properties getHealthCheckProperties(){     return healthCheckProperties;   }   public void setHealthCheckProperties(  Properties healthCheckProperties){     this.healthCheckProperties.putAll(healthCheckProperties);   }   public void addHealthCheckProperty(  String key,  String value){     healthCheckProperties.setProperty(key,value);   }   public boolean isReadOnly(){     return isReadOnly;   }   public void setReadOnly(  boolean readOnly){     this.isReadOnly=readOnly;   }   public boolean isRegisterMbeans(){     return isRegisterMbeans;   }   public void setRegisterMbeans(  boolean register){     this.isRegisterMbeans=register;   }   /**   * {@inheritDoc}   */   @Override public long getLeakDetectionThreshold(){     return leakDetectionThreshold;   }   /**   * {@inheritDoc}   */   @Override public void setLeakDetectionThreshold(  long leakDetectionThresholdMs){     this.leakDetectionThreshold=leakDetectionThresholdMs;   }   /**   * {@inheritDoc}   */   @Override public long getMaxLifetime(){     return maxLifetime;   }   /**   * {@inheritDoc}   */   @Override public void setMaxLifetime(  long maxLifetimeMs){     this.maxLifetime=maxLifetimeMs;   }   /**   * {@inheritDoc}   */   @Override public int getMaximumPoolSize(){     return maxPoolSize;   }   /**   * {@inheritDoc}   */   @Override public void setMaximumPoolSize(  int maxPoolSize){     if (maxPoolSize < 1) {       throw new IllegalArgumentException(\"maxPoolSize cannot be less than 1\");     }     this.maxPoolSize=maxPoolSize;   }   /**   * {@inheritDoc}   */   @Override public int getMinimumIdle(){     return minIdle;   }   /**   * {@inheritDoc}   */   @Override public void setMinimumIdle(  int minIdle){     if (minIdle < 0) {       throw new IllegalArgumentException(\"minimumIdle cannot be negative\");     }     this.minIdle=minIdle;   }   /**   * Get the default password to use for DataSource.getConnection(username, password) calls.  * @return the password  */   public String getPassword(){     return password;   }   /**   * Set the default password to use for DataSource.getConnection(username, password) calls.  * @param password the password  */   public void setPassword(  String password){     this.password=password;   }   /**   * {@inheritDoc}   */   @Override public String getPoolName(){     return poolName;   }   /**   * Set the name of the connection pool.  This is primarily used for the MBean to uniquely identify the pool configuration.  * @param poolName the name of the connection pool to use  */   public void setPoolName(  String poolName){     this.poolName=poolName;   }   public String getTransactionIsolation(){     return transactionIsolationName;   }   /**   * Set the default transaction isolation level.  The specified value is the constant name from the <code>Connection</code> class, eg.  <code>TRANSACTION_REPEATABLE_READ</code>.  * @param isolationLevel the name of the isolation level  */   public void setTransactionIsolation(  String isolationLevel){     this.transactionIsolationName=isolationLevel;   }   /**   * Get the default username used for DataSource.getConnection(username, password) calls.  * @return the username  */   public String getUsername(){     return username;   }   /**   * Set the default username used for DataSource.getConnection(username, password) calls.  * @param username the username  */   public void setUsername(  String username){     this.username=username;   }   /**   * Get the thread factory used to create threads.  * @return the thread factory (may be null, in which case the default thread factory is used)  */   public ThreadFactory getThreadFactory(){     return threadFactory;   }   /**   * Set the thread factory to be used to create threads.  * @param threadFactory the thread factory (setting to null causes the default thread factory to be used)  */   public void setThreadFactory(  ThreadFactory threadFactory){     this.threadFactory=threadFactory;   }   public void validate(){     Logger logger=LoggerFactory.getLogger(getClass());     validateNumerics();     if (connectionCustomizerClassName != null) {       try {         getClass().getClassLoader().loadClass(connectionCustomizerClassName);       }  catch (      Exception e) {         logger.warn(\"connectionCustomizationClass specified class '\" + connectionCustomizerClassName + \"' could not be loaded\",e);         connectionCustomizerClassName=null;       }     }     if (driverClassName != null && jdbcUrl == null) {       logger.error(\"when specifying driverClassName, jdbcUrl must also be specified\");       throw new IllegalStateException(\"when specifying driverClassName, jdbcUrl must also be specified\");     }  else     if (driverClassName != null && dataSourceClassName != null) {       logger.error(\"both driverClassName and dataSourceClassName are specified, one or the other should be used\");       throw new IllegalStateException(\"both driverClassName and dataSourceClassName are specified, one or the other should be used\");     }  else     if (jdbcUrl != null) {     }  else     if (dataSource == null && dataSourceClassName == null) {       logger.error(\"one of either dataSource, dataSourceClassName, or jdbcUrl and driverClassName must be specified\");       throw new IllegalArgumentException(\"one of either dataSource or dataSourceClassName must be specified\");     }  else     if (dataSource != null && dataSourceClassName != null) {       logger.warn(\"both dataSource and dataSourceClassName are specified, ignoring dataSourceClassName\");     }     if (transactionIsolationName != null) {       UtilityElf.getTransactionIsolation(transactionIsolationName);     }     if (poolName == null) {       poolName=\"HikariPool-\" + poolNumber++;     }     if (LOGGER.isDebugEnabled() || unitTest) {       logConfiguration();     }   }   private void validateNumerics(){     Logger logger=LoggerFactory.getLogger(getClass());     if (validationTimeout > connectionTimeout && connectionTimeout != 0) {       logger.warn(\"validationTimeout is greater than connectionTimeout, setting validationTimeout to connectionTimeout.\");       validationTimeout=connectionTimeout;     }     if (minIdle < 0 || minIdle > maxPoolSize) {       minIdle=maxPoolSize;     }     if (maxLifetime < 0) {       logger.error(\"maxLifetime cannot be negative.\");       throw new IllegalArgumentException(\"maxLifetime cannot be negative.\");     }  else     if (maxLifetime > 0 && maxLifetime < TimeUnit.SECONDS.toMillis(30)) {       logger.warn(\"maxLifetime is less than 30000ms, using default {}ms.\",MAX_LIFETIME);       maxLifetime=MAX_LIFETIME;     }     if (idleTimeout != 0 && idleTimeout < TimeUnit.SECONDS.toMillis(10)) {       logger.warn(\"idleTimeout is less than 10000ms, using default {}ms.\",IDLE_TIMEOUT);       idleTimeout=IDLE_TIMEOUT;     }  else     if (idleTimeout > maxLifetime && maxLifetime > 0) {       logger.warn(\"idleTimeout is greater than maxLifetime, setting to maxLifetime.\");       idleTimeout=maxLifetime;     }     if (leakDetectionThreshold != 0 && leakDetectionThreshold < TimeUnit.SECONDS.toMillis(2) && !unitTest) {       logger.warn(\"leakDetectionThreshold is less than 2000ms, setting to minimum 2000ms.\");       leakDetectionThreshold=2000L;     }   }   private void logConfiguration(){     LOGGER.debug(\"HikariCP pool {} configuration:\",poolName);     final Set<String> propertyNames=new TreeSet<String>(PropertyBeanSetter.getPropertyNames(HikariConfig.class));     for (    String prop : propertyNames) {       try {         Object value=PropertyBeanSetter.getProperty(prop,this);         if (\"dataSourceProperties\".equals(prop)) {           Properties dsProps=PropertyBeanSetter.copyProperties(dataSourceProperties);           dsProps.setProperty(\"password\",\"<masked>\");           value=dsProps;         }         value=(prop.contains(\"password\") ? \"<masked>\" : value);         LOGGER.debug((prop + \"................................................\").substring(0,32) + (value != null ? value : \"\"));       }  catch (      Exception e) {         continue;       }     }   }   abstract protected void loadProperties(  String propertyFileName);   public void copyState(  AbstractHikariConfig other){     for (    Field field : AbstractHikariConfig.class.getDeclaredFields()) {       if (!Modifier.isFinal(field.getModifiers())) {         field.setAccessible(true);         try {           field.set(other,field.get(this));         }  catch (        Exception e) {           throw new RuntimeException(\"Exception copying HikariConfig state: \" + e.getMessage(),e);         }       }     }   } } ", "sourceAfterFix": "public abstract class AbstractHikariConfig implements HikariConfigMXBean {   private static final Logger LOGGER=LoggerFactory.getLogger(HikariConfig.class);   private static final long CONNECTION_TIMEOUT=TimeUnit.SECONDS.toMillis(30);   private static final long VALIDATION_TIMEOUT=TimeUnit.SECONDS.toMillis(5);   private static final long IDLE_TIMEOUT=TimeUnit.MINUTES.toMillis(10);   private static final long MAX_LIFETIME=TimeUnit.MINUTES.toMillis(30);   private static int poolNumber;   private static boolean unitTest;   private volatile long connectionTimeout;   private volatile long validationTimeout;   private volatile long idleTimeout;   private volatile long leakDetectionThreshold;   private volatile long maxLifetime;   private volatile int maxPoolSize;   private volatile int minIdle;   private String catalog;   private String connectionCustomizerClassName;   private String connectionInitSql;   private String connectionTestQuery;   private String dataSourceClassName;   private String dataSourceJndiName;   private String driverClassName;   private String jdbcUrl;   private String password;   private String poolName;   private String transactionIsolationName;   private String username;   private boolean isAutoCommit;   private boolean isReadOnly;   private boolean isInitializationFailFast;   private boolean isIsolateInternalQueries;   private boolean isRegisterMbeans;   private boolean isAllowPoolSuspension;   private DataSource dataSource;   private Properties dataSourceProperties;   private IConnectionCustomizer customizer;   private ThreadFactory threadFactory;   private Object metricRegistry;   private Object healthCheckRegistry;   private Properties healthCheckProperties;   /**   * Default constructor  */   public AbstractHikariConfig(){     dataSourceProperties=new Properties();     healthCheckProperties=new Properties();     connectionTimeout=CONNECTION_TIMEOUT;     validationTimeout=VALIDATION_TIMEOUT;     idleTimeout=IDLE_TIMEOUT;     isAutoCommit=true;     isInitializationFailFast=true;     minIdle=-1;     maxPoolSize=10;     maxLifetime=MAX_LIFETIME;     customizer=new IConnectionCustomizer(){       @Override public void customize(      Connection connection) throws SQLException {       }     } ;     String systemProp=System.getProperty(\"hikaricp.configurationFile\");     if (systemProp != null) {       loadProperties(systemProp);     }   }   /**   * Construct a HikariConfig from the specified properties object.  * @param properties the name of the property file  */   public AbstractHikariConfig(  Properties properties){     this();     PropertyBeanSetter.setTargetFromProperties(this,properties);   }   /**   * Construct a HikariConfig from the specified property file name.  <code>propertyFileName</code> will first be treated as a path in the file-system, and if that fails the  ClassLoader.getResourceAsStream(propertyFileName) will be tried.  * @param propertyFileName the name of the property file  */   public AbstractHikariConfig(  String propertyFileName){     this();     loadProperties(propertyFileName);   }   /**   * Get the default catalog name to be set on connections.  * @return the default catalog name  */   public String getCatalog(){     return catalog;   }   /**   * Set the default catalog name to be set on connections.  * @param catalog the catalog name, or null  */   public void setCatalog(  String catalog){     this.catalog=catalog;   }   /**   * Get the name of the connection customizer class to instantiate and execute on all new connections.  * @return the name of the customizer class, or null  */   @Deprecated public String getConnectionCustomizerClassName(){     return connectionCustomizerClassName;   }   /**   * Set the name of the connection customizer class to instantiate and execute on all new connections.  * @param connectionCustomizerClassName the name of the customizer class  */   @Deprecated public void setConnectionCustomizerClassName(  String connectionCustomizerClassName){     this.connectionCustomizerClassName=connectionCustomizerClassName;     LOGGER.warn(\"The connectionCustomizerClassName property has been deprecated and may be removed in a future release\");   }   /**   * Get the customizer instance specified by the user.  * @return an instance of IConnectionCustomizer  */   @Deprecated public IConnectionCustomizer getConnectionCustomizer(){     return customizer;   }   /**   * Set the connection customizer to be used by the pool.  * @param customizer an instance of IConnectionCustomizer  */   @Deprecated public void setConnectionCustomizer(  IConnectionCustomizer customizer){     this.customizer=customizer;     LOGGER.warn(\"The connectionCustomizer property has been deprecated and may be removed in a future release\");   }   /**   * Get the SQL query to be executed to test the validity of connections.  * @return the SQL query string, or null   */   public String getConnectionTestQuery(){     return connectionTestQuery;   }   /**   * Set the SQL query to be executed to test the validity of connections. Using the JDBC4 <code>Connection.isValid()</code> method to test connection validity can be more efficient on some databases and is recommended.  See  {@link HikariConfig#setJdbc4ConnectionTest(boolean)}.  * @param connectionTestQuery a SQL query string  */   public void setConnectionTestQuery(  String connectionTestQuery){     this.connectionTestQuery=connectionTestQuery;   }   /**   * Get the SQL string that will be executed on all new connections when they are created, before they are added to the pool.  * @return the SQL to execute on new connections, or null  */   public String getConnectionInitSql(){     return connectionInitSql;   }   /**   * Set the SQL string that will be executed on all new connections when they are created, before they are added to the pool.  If this query fails, it will be treated as a failed connection attempt.  * @param connectionInitSql the SQL to execute on new connections  */   public void setConnectionInitSql(  String connectionInitSql){     this.connectionInitSql=connectionInitSql;   }   /**   * {@inheritDoc}   */   @Override public long getConnectionTimeout(){     return connectionTimeout;   }   /**   * {@inheritDoc}   */   @Override public void setConnectionTimeout(  long connectionTimeoutMs){     if (connectionTimeoutMs == 0) {       this.connectionTimeout=Integer.MAX_VALUE;     }  else     if (connectionTimeoutMs < 1000) {       throw new IllegalArgumentException(\"connectionTimeout cannot be less than 1000ms\");     }  else {       this.connectionTimeout=connectionTimeoutMs;     }   }   /**   * {@inheritDoc}   */   @Override public long getValidationTimeout(){     return validationTimeout;   }   /**   * {@inheritDoc}   */   @Override public void setValidationTimeout(  long validationTimeoutMs){     if (validationTimeoutMs < 1000) {       throw new IllegalArgumentException(\"validationTimeout cannot be less than 1000ms\");     }  else {       this.validationTimeout=validationTimeoutMs;     }   }   /**   * Get the  {@link DataSource} that has been explicitly specified to be wrapped by thepool.  * @return the {@link DataSource} instance, or null  */   public DataSource getDataSource(){     return dataSource;   }   /**   * Set a  {@link DataSource} for the pool to explicitly wrap.  This setter is notavailable through property file based initialization.  * @param dataSource a specific {@link DataSource} to be wrapped by the pool  */   public void setDataSource(  DataSource dataSource){     this.dataSource=dataSource;   }   public String getDataSourceClassName(){     return dataSourceClassName;   }   public void setDataSourceClassName(  String className){     this.dataSourceClassName=className;   }   public void addDataSourceProperty(  String propertyName,  Object value){     dataSourceProperties.put(propertyName,value);   }   public String getDataSourceJNDI(){     return this.dataSourceJndiName;   }   public void setDataSourceJNDI(  String jndiDataSource){     this.dataSourceJndiName=jndiDataSource;   }   public Properties getDataSourceProperties(){     return dataSourceProperties;   }   public void setDataSourceProperties(  Properties dsProperties){     dataSourceProperties.putAll(dsProperties);   }   public String getDriverClassName(){     return driverClassName;   }   public void setDriverClassName(  String driverClassName){     try {       Class<?> driverClass=this.getClass().getClassLoader().loadClass(driverClassName);       driverClass.newInstance();       this.driverClassName=driverClassName;     }  catch (    Exception e) {       throw new RuntimeException(\"driverClassName specified class '\" + driverClassName + \"' could not be loaded\",e);     }   }   /**   * {@inheritDoc}   */   @Override public long getIdleTimeout(){     return idleTimeout;   }   /**   * {@inheritDoc}   */   @Override public void setIdleTimeout(  long idleTimeoutMs){     if (idleTimeoutMs < 0) {       throw new IllegalArgumentException(\"idleTimeout cannot be negative\");     }     this.idleTimeout=idleTimeoutMs;   }   public String getJdbcUrl(){     return jdbcUrl;   }   public void setJdbcUrl(  String jdbcUrl){     this.jdbcUrl=jdbcUrl;   }   /**   * Get the default auto-commit behavior of connections in the pool.  * @return the default auto-commit behavior of connections  */   public boolean isAutoCommit(){     return isAutoCommit;   }   /**   * Set the default auto-commit behavior of connections in the pool.  * @param isAutoCommit the desired auto-commit default for connections  */   public void setAutoCommit(  boolean isAutoCommit){     this.isAutoCommit=isAutoCommit;   }   /**   * Get the pool suspension behavior (allowed or disallowed).  * @return the pool suspension behavior  */   public boolean isAllowPoolSuspension(){     return isAllowPoolSuspension;   }   /**   * Set whether or not pool suspension is allowed.  There is a performance impact when pool suspension is enabled.  Unless you need it (for a redundancy system for example) do not enable it.  * @param isAllowPoolSuspension the desired pool suspension allowance  */   public void setAllowPoolSuspension(  boolean isAllowPoolSuspension){     this.isAllowPoolSuspension=isAllowPoolSuspension;   }   /**   * Get whether or not the construction of the pool should throw an exception if the minimum number of connections cannot be created.  * @return whether or not initialization should fail on error immediately  */   public boolean isInitializationFailFast(){     return isInitializationFailFast;   }   /**   * Set whether or not the construction of the pool should throw an exception if the minimum number of connections cannot be created.  * @param failFast true if the pool should fail if the minimum connections cannot be created  */   public void setInitializationFailFast(  boolean failFast){     isInitializationFailFast=failFast;   }   public boolean isIsolateInternalQueries(){     return isIsolateInternalQueries;   }   public void setIsolateInternalQueries(  boolean isolate){     this.isIsolateInternalQueries=isolate;   }   @Deprecated public boolean isJdbc4ConnectionTest(){     return false;   }   @Deprecated public void setJdbc4ConnectionTest(  boolean useIsValid){     LOGGER.warn(\"The jdbcConnectionTest property is now deprecated, see the documentation for connectionTestQuery\");   }   /**   * Get the Codahale MetricRegistry, could be null.  * @return the codahale MetricRegistry instance  */   public Object getMetricRegistry(){     return metricRegistry;   }   /**   * Set a Codahale MetricRegistry to use for HikariCP.  * @param metricRegistry the Codahale MetricRegistry to set  */   public void setMetricRegistry(  Object metricRegistry){     if (metricRegistry != null) {       if (metricRegistry instanceof String) {         try {           InitialContext initCtx=new InitialContext();           metricRegistry=(MetricRegistry)initCtx.lookup((String)metricRegistry);         }  catch (        NamingException e) {           throw new IllegalArgumentException(e);         }       }       if (!(metricRegistry instanceof MetricRegistry)) {         throw new IllegalArgumentException(\"Class must be an instance of com.codahale.metrics.MetricRegistry\");       }     }     this.metricRegistry=metricRegistry;   }   /**   * Get the Codahale HealthCheckRegistry, could be null.  * @return the Codahale HealthCheckRegistry instance  */   public Object getHealthCheckRegistry(){     return healthCheckRegistry;   }   /**   * Set a Codahale HealthCheckRegistry to use for HikariCP.  * @param healthCheckRegistry the Codahale HealthCheckRegistry to set  */   public void setHealthCheckRegistry(  Object healthCheckRegistry){     if (healthCheckRegistry != null) {       if (healthCheckRegistry instanceof String) {         try {           InitialContext initCtx=new InitialContext();           healthCheckRegistry=(HealthCheckRegistry)initCtx.lookup((String)healthCheckRegistry);         }  catch (        NamingException e) {           throw new IllegalArgumentException(e);         }       }       if (!(healthCheckRegistry instanceof HealthCheckRegistry)) {         throw new IllegalArgumentException(\"Class must be an instance of com.codahale.metrics.health.HealthCheckRegistry\");       }     }     this.healthCheckRegistry=healthCheckRegistry;   }   public Properties getHealthCheckProperties(){     return healthCheckProperties;   }   public void setHealthCheckProperties(  Properties healthCheckProperties){     this.healthCheckProperties.putAll(healthCheckProperties);   }   public void addHealthCheckProperty(  String key,  String value){     healthCheckProperties.setProperty(key,value);   }   public boolean isReadOnly(){     return isReadOnly;   }   public void setReadOnly(  boolean readOnly){     this.isReadOnly=readOnly;   }   public boolean isRegisterMbeans(){     return isRegisterMbeans;   }   public void setRegisterMbeans(  boolean register){     this.isRegisterMbeans=register;   }   /**   * {@inheritDoc}   */   @Override public long getLeakDetectionThreshold(){     return leakDetectionThreshold;   }   /**   * {@inheritDoc}   */   @Override public void setLeakDetectionThreshold(  long leakDetectionThresholdMs){     this.leakDetectionThreshold=leakDetectionThresholdMs;   }   /**   * {@inheritDoc}   */   @Override public long getMaxLifetime(){     return maxLifetime;   }   /**   * {@inheritDoc}   */   @Override public void setMaxLifetime(  long maxLifetimeMs){     this.maxLifetime=maxLifetimeMs;   }   /**   * {@inheritDoc}   */   @Override public int getMaximumPoolSize(){     return maxPoolSize;   }   /**   * {@inheritDoc}   */   @Override public void setMaximumPoolSize(  int maxPoolSize){     if (maxPoolSize < 1) {       throw new IllegalArgumentException(\"maxPoolSize cannot be less than 1\");     }     this.maxPoolSize=maxPoolSize;   }   /**   * {@inheritDoc}   */   @Override public int getMinimumIdle(){     return minIdle;   }   /**   * {@inheritDoc}   */   @Override public void setMinimumIdle(  int minIdle){     if (minIdle < 0) {       throw new IllegalArgumentException(\"minimumIdle cannot be negative\");     }     this.minIdle=minIdle;   }   /**   * Get the default password to use for DataSource.getConnection(username, password) calls.  * @return the password  */   public String getPassword(){     return password;   }   /**   * Set the default password to use for DataSource.getConnection(username, password) calls.  * @param password the password  */   public void setPassword(  String password){     this.password=password;   }   /**   * {@inheritDoc}   */   @Override public String getPoolName(){     return poolName;   }   /**   * Set the name of the connection pool.  This is primarily used for the MBean to uniquely identify the pool configuration.  * @param poolName the name of the connection pool to use  */   public void setPoolName(  String poolName){     this.poolName=poolName;   }   public String getTransactionIsolation(){     return transactionIsolationName;   }   /**   * Set the default transaction isolation level.  The specified value is the constant name from the <code>Connection</code> class, eg.  <code>TRANSACTION_REPEATABLE_READ</code>.  * @param isolationLevel the name of the isolation level  */   public void setTransactionIsolation(  String isolationLevel){     this.transactionIsolationName=isolationLevel;   }   /**   * Get the default username used for DataSource.getConnection(username, password) calls.  * @return the username  */   public String getUsername(){     return username;   }   /**   * Set the default username used for DataSource.getConnection(username, password) calls.  * @param username the username  */   public void setUsername(  String username){     this.username=username;   }   /**   * Get the thread factory used to create threads.  * @return the thread factory (may be null, in which case the default thread factory is used)  */   public ThreadFactory getThreadFactory(){     return threadFactory;   }   /**   * Set the thread factory to be used to create threads.  * @param threadFactory the thread factory (setting to null causes the default thread factory to be used)  */   public void setThreadFactory(  ThreadFactory threadFactory){     this.threadFactory=threadFactory;   }   public void validate(){     Logger logger=LoggerFactory.getLogger(getClass());     validateNumerics();     if (connectionCustomizerClassName != null) {       try {         getClass().getClassLoader().loadClass(connectionCustomizerClassName);       }  catch (      Exception e) {         logger.warn(\"connectionCustomizationClass specified class '\" + connectionCustomizerClassName + \"' could not be loaded\",e);         connectionCustomizerClassName=null;       }     }     if (driverClassName != null && jdbcUrl == null) {       logger.error(\"when specifying driverClassName, jdbcUrl must also be specified\");       throw new IllegalStateException(\"when specifying driverClassName, jdbcUrl must also be specified\");     }  else     if (driverClassName != null && dataSourceClassName != null) {       logger.error(\"both driverClassName and dataSourceClassName are specified, one or the other should be used\");       throw new IllegalStateException(\"both driverClassName and dataSourceClassName are specified, one or the other should be used\");     }  else     if (jdbcUrl != null) {     }  else     if (dataSource == null && dataSourceClassName == null) {       logger.error(\"one of either dataSource, dataSourceClassName, or jdbcUrl and driverClassName must be specified\");       throw new IllegalArgumentException(\"one of either dataSource or dataSourceClassName must be specified\");     }  else     if (dataSource != null && dataSourceClassName != null) {       logger.warn(\"both dataSource and dataSourceClassName are specified, ignoring dataSourceClassName\");     }     if (transactionIsolationName != null) {       UtilityElf.getTransactionIsolation(transactionIsolationName);     }     if (poolName == null) {       poolName=\"HikariPool-\" + poolNumber++;     }     if (LOGGER.isDebugEnabled() || unitTest) {       logConfiguration();     }   }   private void validateNumerics(){     Logger logger=LoggerFactory.getLogger(getClass());     if (validationTimeout > connectionTimeout && connectionTimeout != 0) {       logger.warn(\"validationTimeout is greater than connectionTimeout, setting validationTimeout to connectionTimeout.\");       validationTimeout=connectionTimeout;     }     if (minIdle < 0 || minIdle > maxPoolSize) {       minIdle=maxPoolSize;     }     if (maxLifetime < 0) {       logger.error(\"maxLifetime cannot be negative.\");       throw new IllegalArgumentException(\"maxLifetime cannot be negative.\");     }  else     if (maxLifetime > 0 && maxLifetime < TimeUnit.SECONDS.toMillis(30)) {       logger.warn(\"maxLifetime is less than 30000ms, using default {}ms.\",MAX_LIFETIME);       maxLifetime=MAX_LIFETIME;     }     if (idleTimeout != 0 && idleTimeout < TimeUnit.SECONDS.toMillis(10)) {       logger.warn(\"idleTimeout is less than 10000ms, using default {}ms.\",IDLE_TIMEOUT);       idleTimeout=IDLE_TIMEOUT;     }  else     if (idleTimeout > maxLifetime && maxLifetime > 0) {       logger.warn(\"idleTimeout is greater than maxLifetime, setting to maxLifetime.\");       idleTimeout=maxLifetime;     }     if (leakDetectionThreshold != 0 && leakDetectionThreshold < TimeUnit.SECONDS.toMillis(2) && !unitTest) {       logger.warn(\"leakDetectionThreshold is less than 2000ms, setting to minimum 2000ms.\");       leakDetectionThreshold=2000L;     }   }   private void logConfiguration(){     LOGGER.debug(\"HikariCP pool {} configuration:\",poolName);     final Set<String> propertyNames=new TreeSet<String>(PropertyBeanSetter.getPropertyNames(HikariConfig.class));     for (    String prop : propertyNames) {       try {         Object value=PropertyBeanSetter.getProperty(prop,this);         if (\"dataSourceProperties\".equals(prop)) {           Properties dsProps=PropertyBeanSetter.copyProperties(dataSourceProperties);           dsProps.setProperty(\"password\",\"<masked>\");           value=dsProps;         }         value=(prop.contains(\"password\") ? \"<masked>\" : value);         LOGGER.debug((prop + \"................................................\").substring(0,32) + (value != null ? value : \"\"));       }  catch (      Exception e) {         continue;       }     }   }   abstract protected void loadProperties(  String propertyFileName);   public void copyState(  AbstractHikariConfig other){     for (    Field field : AbstractHikariConfig.class.getDeclaredFields()) {       if (!Modifier.isFinal(field.getModifiers())) {         field.setAccessible(true);         try {           field.set(other,field.get(this));         }  catch (        Exception e) {           throw new RuntimeException(\"Exception copying HikariConfig state: \" + e.getMessage(),e);         }       }     }   } } "}, {"bugType": "CHANGE_IDENTIFIER", "fixCommitSHA1": "60e0eb1b8bb87242665c37e1f3ecf549b2457206", "fixCommitParentSHA1": "7aa6870af06d990f53b00494258d2ead222aeb5a", "bugFilePath": "hikaricp-common/src/main/java/com/zaxxer/hikari/pool/BaseHikariPool.java", "fixPatch": "diff --git a/hikaricp-common/src/main/java/com/zaxxer/hikari/pool/BaseHikariPool.java b/hikaricp-common/src/main/java/com/zaxxer/hikari/pool/BaseHikariPool.java\nindex 50c839b..94ff081 100644\n--- a/hikaricp-common/src/main/java/com/zaxxer/hikari/pool/BaseHikariPool.java\n+++ b/hikaricp-common/src/main/java/com/zaxxer/hikari/pool/BaseHikariPool.java\n@@ -67,7 +67,7 @@\n  *\n  * @author Brett Wooldridge\n  */\n-public abstract class BaseHikariPool implements HikariPoolMBean, IBagStateListener\n+public abstract class BaseHikariPool implements HikariPoolMXBean, IBagStateListener\n {\n    protected final Logger LOGGER = LoggerFactory.getLogger(getClass());\n    private static final long ALIVE_BYPASS_WINDOW = Long.getLong(\"com.zaxxer.hikari.aliveBypassWindow\", 1000L);\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 64, "bugNodeStartChar": 2706, "bugNodeLength": 20269, "fixLineNum": 64, "fixNodeStartChar": 2706, "fixNodeLength": 20270, "sourceBeforeFix": "/**   * This is the primary connection pool class that provides the basic pooling behavior for HikariCP.  * @author Brett Wooldridge  */ public abstract class BaseHikariPool implements HikariPoolMBean, IBagStateListener {   protected final Logger LOGGER=LoggerFactory.getLogger(getClass());   private static final long ALIVE_BYPASS_WINDOW=Long.getLong(\"com.zaxxer.hikari.aliveBypassWindow\",1000L);   protected static final int POOL_RUNNING=0;   protected static final int POOL_SUSPENDED=1;   protected static final int POOL_SHUTDOWN=2;   public final String catalog;   public final boolean isReadOnly;   public final boolean isAutoCommit;   public int transactionIsolation;   protected final PoolUtilities poolUtils;   protected final HikariConfig configuration;   protected final AtomicInteger totalConnections;   protected final ConcurrentBag<PoolBagEntry> connectionBag;   protected final ThreadPoolExecutor addConnectionExecutor;   protected final ThreadPoolExecutor closeConnectionExecutor;   protected final ScheduledThreadPoolExecutor houseKeepingExecutorService;   protected final boolean isUseJdbc4Validation;   protected final boolean isIsolateInternalQueries;   protected volatile int poolState;   protected volatile long connectionTimeout;   protected volatile long validationTimeout;   private final LeakTask leakTask;   private final DataSource dataSource;   private final GlobalPoolLock suspendResumeLock;   private final IConnectionCustomizer connectionCustomizer;   private final AtomicReference<Throwable> lastConnectionFailure;   private final String username;   private final String password;   private volatile MetricsTracker metricsTracker;   private volatile boolean isRecordMetrics;   /**   * Construct a HikariPool with the specified configuration.  * @param configuration a HikariConfig instance  */   public BaseHikariPool(  HikariConfig configuration){     this(configuration,configuration.getUsername(),configuration.getPassword());   }   /**   * Construct a HikariPool with the specified configuration.  We cache lots of configuration items in class-local final members for speed.  * @param configuration a HikariConfig instance  * @param username authentication username  * @param password authentication password  */   public BaseHikariPool(  HikariConfig configuration,  String username,  String password){     this.username=username;     this.password=password;     this.configuration=configuration;     this.poolUtils=new PoolUtilities(configuration);     this.connectionBag=createConcurrentBag(this);     this.totalConnections=new AtomicInteger();     this.connectionTimeout=configuration.getConnectionTimeout();     this.validationTimeout=configuration.getValidationTimeout();     this.lastConnectionFailure=new AtomicReference<Throwable>();     this.isReadOnly=configuration.isReadOnly();     this.isAutoCommit=configuration.isAutoCommit();     this.suspendResumeLock=configuration.isAllowPoolSuspension() ? new GlobalPoolLock(true) : GlobalPoolLock.FAUX_LOCK;     this.catalog=configuration.getCatalog();     this.connectionCustomizer=initializeCustomizer();     this.transactionIsolation=getTransactionIsolation(configuration.getTransactionIsolation());     this.isIsolateInternalQueries=configuration.isIsolateInternalQueries();     this.isUseJdbc4Validation=configuration.getConnectionTestQuery() == null;     setMetricRegistry(configuration.getMetricRegistry());     setHealthCheckRegistry(configuration.getHealthCheckRegistry());     this.dataSource=poolUtils.initializeDataSource(configuration.getDataSourceClassName(),configuration.getDataSource(),configuration.getDataSourceProperties(),configuration.getDriverClassName(),configuration.getJdbcUrl(),username,password);     this.addConnectionExecutor=createThreadPoolExecutor(configuration.getMaximumPoolSize(),\"HikariCP connection filler (pool \" + configuration.getPoolName() + \")\",configuration.getThreadFactory(),new ThreadPoolExecutor.DiscardPolicy());     this.closeConnectionExecutor=createThreadPoolExecutor(4,\"HikariCP connection closer (pool \" + configuration.getPoolName() + \")\",configuration.getThreadFactory(),new ThreadPoolExecutor.CallerRunsPolicy());     long delayPeriod=Long.getLong(\"com.zaxxer.hikari.housekeeping.periodMs\",TimeUnit.SECONDS.toMillis(30L));     ThreadFactory threadFactory=configuration.getThreadFactory() != null ? configuration.getThreadFactory() : new DefaultThreadFactory(\"Hikari Housekeeping Timer (pool \" + configuration.getPoolName() + \")\",true);     this.houseKeepingExecutorService=new ScheduledThreadPoolExecutor(1,threadFactory,new ThreadPoolExecutor.DiscardPolicy());     this.houseKeepingExecutorService.scheduleAtFixedRate(getHouseKeeper(),delayPeriod,delayPeriod,TimeUnit.MILLISECONDS);     this.houseKeepingExecutorService.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);     this.leakTask=(configuration.getLeakDetectionThreshold() == 0) ? LeakTask.NO_LEAK : new LeakTask(configuration.getLeakDetectionThreshold(),houseKeepingExecutorService);     setRemoveOnCancelPolicy(houseKeepingExecutorService);     poolUtils.setLoginTimeout(dataSource,connectionTimeout);     registerMBeans(configuration,this);     initializeConnections();   }   /**   * Get a connection from the pool, or timeout after connectionTimeout milliseconds.  * @return a java.sql.Connection instance  * @throws SQLException thrown if a timeout occurs trying to obtain a connection  */   public final Connection getConnection() throws SQLException {     return getConnection(connectionTimeout);   }   /**   * Get a connection from the pool, or timeout after the specified number of milliseconds.  * @param hardTimeout the maximum time to wait for a connection from the pool  * @return a java.sql.Connection instance  * @throws SQLException thrown if a timeout occurs trying to obtain a connection  */   public final Connection getConnection(  final long hardTimeout) throws SQLException {     suspendResumeLock.acquire();     long timeout=hardTimeout;     final long start=System.currentTimeMillis();     final MetricsContext metricsContext=(isRecordMetrics ? metricsTracker.recordConnectionRequest(start) : MetricsTracker.NO_CONTEXT);     try {       do {         final PoolBagEntry bagEntry=connectionBag.borrow(timeout,TimeUnit.MILLISECONDS);         if (bagEntry == null) {           break;         }         final long now=System.currentTimeMillis();         if (bagEntry.evicted || (now - bagEntry.lastAccess > ALIVE_BYPASS_WINDOW && !isConnectionAlive(bagEntry.connection))) {           closeConnection(bagEntry,\"(connection evicted or dead)\");           timeout=hardTimeout - elapsedTimeMs(start);         }  else {           metricsContext.setConnectionLastOpen(bagEntry,now);           metricsContext.stop();           return ProxyFactory.getProxyConnection((HikariPool)this,bagEntry,leakTask.start(bagEntry));         }       }  while (timeout > 0L);     }  catch (    InterruptedException e) {       throw new SQLException(\"Interrupted during connection acquisition\",e);     }  finally {       suspendResumeLock.release();     }     logPoolState(\"Timeout failure \");     throw new SQLTimeoutException(String.format(\"Timeout after %dms of waiting for a connection.\",elapsedTimeMs(start)),lastConnectionFailure.getAndSet(null));   }   /**   * Release a connection back to the pool, or permanently close it if it is broken.  * @param bagEntry the PoolBagEntry to release back to the pool  */   public final void releaseConnection(  final PoolBagEntry bagEntry){     metricsTracker.recordConnectionUsage(bagEntry);     if (bagEntry.evicted) {       LOGGER.debug(\"Connection returned to pool {} is broken or evicted.  Closing connection.\",configuration.getPoolName());       closeConnection(bagEntry,\"(connection broken or evicted)\");     }  else {       connectionBag.requite(bagEntry);     }   }   /**   * Shutdown the pool, closing all idle connections and aborting or closing active connections.  * @throws InterruptedException thrown if the thread is interrupted during shutdown  */   public final void shutdown() throws InterruptedException {     if (poolState != POOL_SHUTDOWN) {       poolState=POOL_SHUTDOWN;       LOGGER.info(\"HikariCP pool {} is shutting down.\",configuration.getPoolName());       logPoolState(\"Before shutdown \");       connectionBag.close();       softEvictConnections();       houseKeepingExecutorService.shutdown();       addConnectionExecutor.shutdownNow();       houseKeepingExecutorService.awaitTermination(5L,TimeUnit.SECONDS);       addConnectionExecutor.awaitTermination(5L,TimeUnit.SECONDS);       final ExecutorService assassinExecutor=createThreadPoolExecutor(configuration.getMaximumPoolSize(),\"HikariCP connection assassin\",configuration.getThreadFactory(),new ThreadPoolExecutor.CallerRunsPolicy());       final long start=System.currentTimeMillis();       do {         softEvictConnections();         abortActiveConnections(assassinExecutor);       }  while (getTotalConnections() > 0 && elapsedTimeMs(start) < TimeUnit.SECONDS.toMillis(5));       assassinExecutor.shutdown();       assassinExecutor.awaitTermination(5L,TimeUnit.SECONDS);       closeConnectionExecutor.shutdown();       closeConnectionExecutor.awaitTermination(5L,TimeUnit.SECONDS);       logPoolState(\"After shutdown \");       unregisterMBeans(configuration,this);       metricsTracker.close();     }   }   /**   * Evict a connection from the pool.  * @param proxyConnection the connection to evict  */   public final void evictConnection(  IHikariConnectionProxy proxyConnection){     closeConnection(proxyConnection.getPoolBagEntry(),\"(connection evicted by user)\");   }   /**   * Get the wrapped DataSource.  * @return the wrapped DataSource  */   public final DataSource getDataSource(){     return dataSource;   }   /**   * Get the pool configuration object.  * @return the {@link HikariConfig} for this pool  */   public final HikariConfig getConfiguration(){     return configuration;   }   @Override public String toString(){     return configuration.getPoolName();   }   /**   * {@inheritDoc}   */   @Override public final int getActiveConnections(){     return connectionBag.getCount(STATE_IN_USE);   }   /**   * {@inheritDoc}   */   @Override public final int getIdleConnections(){     return connectionBag.getCount(STATE_NOT_IN_USE);   }   /**   * {@inheritDoc}   */   @Override public final int getTotalConnections(){     return connectionBag.size() - connectionBag.getCount(STATE_REMOVED);   }   /**   * {@inheritDoc}   */   @Override public final int getThreadsAwaitingConnection(){     return connectionBag.getPendingQueue();   }   /**   * {@inheritDoc}   */   @Override public final void suspendPool(){     if (suspendResumeLock == GlobalPoolLock.FAUX_LOCK) {       throw new IllegalStateException(\"Pool \" + configuration.getPoolName() + \" is not suspendable\");     }  else     if (poolState != POOL_SUSPENDED) {       suspendResumeLock.suspend();       poolState=POOL_SUSPENDED;     }   }   /**   * {@inheritDoc}   */   @Override public final void resumePool(){     if (poolState == POOL_SUSPENDED) {       poolState=POOL_RUNNING;       addBagItem();       suspendResumeLock.resume();     }   }   public void setMetricRegistry(  Object metricRegistry){     this.isRecordMetrics=metricRegistry != null;     if (isRecordMetrics) {       this.metricsTracker=new CodaHaleMetricsTracker(this,(MetricRegistry)metricRegistry);     }  else {       this.metricsTracker=new MetricsTracker(this);     }   }   public void setHealthCheckRegistry(  Object healthCheckRegistry){     if (healthCheckRegistry != null) {       CodahaleHealthChecker.registerHealthChecks(this,(HealthCheckRegistry)healthCheckRegistry);     }   }   /**   * {@inheritDoc}   */   @Override public Future<Boolean> addBagItem(){     FutureTask<Boolean> future=new FutureTask<Boolean>(new Runnable(){       public void run(){         long sleepBackoff=200L;         final int minimumIdle=configuration.getMinimumIdle();         final int maxPoolSize=configuration.getMaximumPoolSize();         while (poolState == POOL_RUNNING && totalConnections.get() < maxPoolSize && getIdleConnections() <= minimumIdle && !addConnection()) {           quietlySleep(sleepBackoff);           sleepBackoff=Math.min(connectionTimeout / 2,(long)((double)sleepBackoff * 1.5));         }       }     } ,true);     addConnectionExecutor.execute(future);     return future;   }   /**   * Create and add a single connection to the pool.  */   protected final boolean addConnection(){     if (totalConnections.incrementAndGet() <= configuration.getMaximumPoolSize()) {       Connection connection=null;       try {         connection=(username == null && password == null) ? dataSource.getConnection() : dataSource.getConnection(username,password);         if (isUseJdbc4Validation && !poolUtils.isJdbc4ValidationSupported(connection)) {           throw new SQLException(\"JDBC4 Connection.isValid() method not supported, connection test query must be configured\");         }         final int originalTimeout=poolUtils.getAndSetNetworkTimeout(connection,connectionTimeout);         transactionIsolation=(transactionIsolation < 0 ? connection.getTransactionIsolation() : transactionIsolation);         poolUtils.setupConnection(connection,isAutoCommit,isReadOnly,transactionIsolation,catalog);         connectionCustomizer.customize(connection);         poolUtils.executeSql(connection,configuration.getConnectionInitSql(),isAutoCommit);         poolUtils.setNetworkTimeout(connection,originalTimeout);         connectionBag.add(new PoolBagEntry(connection,this));         lastConnectionFailure.set(null);         return true;       }  catch (      Exception e) {         lastConnectionFailure.set(e);         if (poolState == POOL_RUNNING) {           LOGGER.debug(\"Connection attempt to database {} failed: {}\",configuration.getPoolName(),e.getMessage(),e);         }         poolUtils.quietlyCloseConnection(connection,\"(exception during connection creation)\");       }     }     totalConnections.decrementAndGet();     return false;   }   /**   * Fill pool up from current idle connections (as they are perceived at the point of execution) to minimumIdle connections.  */   protected void fillPool(){     final int connectionsToAdd=configuration.getMinimumIdle() - getIdleConnections();     for (int i=0; i < connectionsToAdd; i++) {       addBagItem();     }     if (connectionsToAdd > 0 && LOGGER.isDebugEnabled()) {       addConnectionExecutor.execute(new Runnable(){         public void run(){           logPoolState(\"After fill \");         }       } );     }   }   /**   * Permanently close the real (underlying) connection (eat any exception).  * @param connectionProxy the connection to actually close  */   protected abstract void closeConnection(  final PoolBagEntry bagEntry,  final String closureReason);   /**   * Check whether the connection is alive or not.  * @param connection the connection to test  * @return true if the connection is alive, false if it is not alive or we timed out  */   protected abstract boolean isConnectionAlive(  final Connection connection);   /**   * Attempt to abort() active connections on Java7+, or close() them on Java6.  * @param assassinExecutor   * @throws InterruptedException   */   protected abstract void abortActiveConnections(  final ExecutorService assassinExecutor) throws InterruptedException ;   /**   * Create the JVM version-specific ConcurrentBag instance used by the pool.  * @param listener the IBagStateListener instance  * @return a ConcurrentBag instance  */   protected abstract ConcurrentBag<PoolBagEntry> createConcurrentBag(  IBagStateListener listener);   /**   * Create the JVM version-specific Housekeeping runnable instance used by the pool.  * @return the HouseKeeper instance  */   protected abstract Runnable getHouseKeeper();   /**   * Fill the pool up to the minimum size.  */   private void initializeConnections(){     if (configuration.isInitializationFailFast()) {       try {         try {           if (!addConnection()) {             shutdown();             throw new PoolInitializationException(lastConnectionFailure.getAndSet(null));           }           ConnectionProxy connection=(ConnectionProxy)getConnection();           connection.getPoolBagEntry().evicted=(configuration.getMinimumIdle() == 0);           connection.close();         }  catch (        SQLException e) {           shutdown();           throw new PoolInitializationException(e);         }       }  catch (      InterruptedException ie) {         throw new PoolInitializationException(ie);       }     }     fillPool();   }   /**   * Construct the user's connection customizer, if specified.  * @return an IConnectionCustomizer instance  */   @SuppressWarnings(\"deprecation\") private IConnectionCustomizer initializeCustomizer(){     if (configuration.getConnectionCustomizerClassName() != null) {       return createInstance(configuration.getConnectionCustomizerClassName(),IConnectionCustomizer.class);     }     return configuration.getConnectionCustomizer();   }   public final void logPoolState(  String... prefix){     if (LOGGER.isDebugEnabled()) {       LOGGER.debug(\"{}pool stats {} (total={}, inUse={}, avail={}, waiting={})\",(prefix.length > 0 ? prefix[0] : \"\"),configuration.getPoolName(),getTotalConnections(),getActiveConnections(),getIdleConnections(),getThreadsAwaitingConnection());     }   } } ", "sourceAfterFix": "/**   * This is the primary connection pool class that provides the basic pooling behavior for HikariCP.  * @author Brett Wooldridge  */ public abstract class BaseHikariPool implements HikariPoolMXBean, IBagStateListener {   protected final Logger LOGGER=LoggerFactory.getLogger(getClass());   private static final long ALIVE_BYPASS_WINDOW=Long.getLong(\"com.zaxxer.hikari.aliveBypassWindow\",1000L);   protected static final int POOL_RUNNING=0;   protected static final int POOL_SUSPENDED=1;   protected static final int POOL_SHUTDOWN=2;   public final String catalog;   public final boolean isReadOnly;   public final boolean isAutoCommit;   public int transactionIsolation;   protected final PoolUtilities poolUtils;   protected final HikariConfig configuration;   protected final AtomicInteger totalConnections;   protected final ConcurrentBag<PoolBagEntry> connectionBag;   protected final ThreadPoolExecutor addConnectionExecutor;   protected final ThreadPoolExecutor closeConnectionExecutor;   protected final ScheduledThreadPoolExecutor houseKeepingExecutorService;   protected final boolean isUseJdbc4Validation;   protected final boolean isIsolateInternalQueries;   protected volatile int poolState;   protected volatile long connectionTimeout;   protected volatile long validationTimeout;   private final LeakTask leakTask;   private final DataSource dataSource;   private final GlobalPoolLock suspendResumeLock;   private final IConnectionCustomizer connectionCustomizer;   private final AtomicReference<Throwable> lastConnectionFailure;   private final String username;   private final String password;   private volatile MetricsTracker metricsTracker;   private volatile boolean isRecordMetrics;   /**   * Construct a HikariPool with the specified configuration.  * @param configuration a HikariConfig instance  */   public BaseHikariPool(  HikariConfig configuration){     this(configuration,configuration.getUsername(),configuration.getPassword());   }   /**   * Construct a HikariPool with the specified configuration.  We cache lots of configuration items in class-local final members for speed.  * @param configuration a HikariConfig instance  * @param username authentication username  * @param password authentication password  */   public BaseHikariPool(  HikariConfig configuration,  String username,  String password){     this.username=username;     this.password=password;     this.configuration=configuration;     this.poolUtils=new PoolUtilities(configuration);     this.connectionBag=createConcurrentBag(this);     this.totalConnections=new AtomicInteger();     this.connectionTimeout=configuration.getConnectionTimeout();     this.validationTimeout=configuration.getValidationTimeout();     this.lastConnectionFailure=new AtomicReference<Throwable>();     this.isReadOnly=configuration.isReadOnly();     this.isAutoCommit=configuration.isAutoCommit();     this.suspendResumeLock=configuration.isAllowPoolSuspension() ? new GlobalPoolLock(true) : GlobalPoolLock.FAUX_LOCK;     this.catalog=configuration.getCatalog();     this.connectionCustomizer=initializeCustomizer();     this.transactionIsolation=getTransactionIsolation(configuration.getTransactionIsolation());     this.isIsolateInternalQueries=configuration.isIsolateInternalQueries();     this.isUseJdbc4Validation=configuration.getConnectionTestQuery() == null;     setMetricRegistry(configuration.getMetricRegistry());     setHealthCheckRegistry(configuration.getHealthCheckRegistry());     this.dataSource=poolUtils.initializeDataSource(configuration.getDataSourceClassName(),configuration.getDataSource(),configuration.getDataSourceProperties(),configuration.getDriverClassName(),configuration.getJdbcUrl(),username,password);     this.addConnectionExecutor=createThreadPoolExecutor(configuration.getMaximumPoolSize(),\"HikariCP connection filler (pool \" + configuration.getPoolName() + \")\",configuration.getThreadFactory(),new ThreadPoolExecutor.DiscardPolicy());     this.closeConnectionExecutor=createThreadPoolExecutor(4,\"HikariCP connection closer (pool \" + configuration.getPoolName() + \")\",configuration.getThreadFactory(),new ThreadPoolExecutor.CallerRunsPolicy());     long delayPeriod=Long.getLong(\"com.zaxxer.hikari.housekeeping.periodMs\",TimeUnit.SECONDS.toMillis(30L));     ThreadFactory threadFactory=configuration.getThreadFactory() != null ? configuration.getThreadFactory() : new DefaultThreadFactory(\"Hikari Housekeeping Timer (pool \" + configuration.getPoolName() + \")\",true);     this.houseKeepingExecutorService=new ScheduledThreadPoolExecutor(1,threadFactory,new ThreadPoolExecutor.DiscardPolicy());     this.houseKeepingExecutorService.scheduleAtFixedRate(getHouseKeeper(),delayPeriod,delayPeriod,TimeUnit.MILLISECONDS);     this.houseKeepingExecutorService.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);     this.leakTask=(configuration.getLeakDetectionThreshold() == 0) ? LeakTask.NO_LEAK : new LeakTask(configuration.getLeakDetectionThreshold(),houseKeepingExecutorService);     setRemoveOnCancelPolicy(houseKeepingExecutorService);     poolUtils.setLoginTimeout(dataSource,connectionTimeout);     registerMBeans(configuration,this);     initializeConnections();   }   /**   * Get a connection from the pool, or timeout after connectionTimeout milliseconds.  * @return a java.sql.Connection instance  * @throws SQLException thrown if a timeout occurs trying to obtain a connection  */   public final Connection getConnection() throws SQLException {     return getConnection(connectionTimeout);   }   /**   * Get a connection from the pool, or timeout after the specified number of milliseconds.  * @param hardTimeout the maximum time to wait for a connection from the pool  * @return a java.sql.Connection instance  * @throws SQLException thrown if a timeout occurs trying to obtain a connection  */   public final Connection getConnection(  final long hardTimeout) throws SQLException {     suspendResumeLock.acquire();     long timeout=hardTimeout;     final long start=System.currentTimeMillis();     final MetricsContext metricsContext=(isRecordMetrics ? metricsTracker.recordConnectionRequest(start) : MetricsTracker.NO_CONTEXT);     try {       do {         final PoolBagEntry bagEntry=connectionBag.borrow(timeout,TimeUnit.MILLISECONDS);         if (bagEntry == null) {           break;         }         final long now=System.currentTimeMillis();         if (bagEntry.evicted || (now - bagEntry.lastAccess > ALIVE_BYPASS_WINDOW && !isConnectionAlive(bagEntry.connection))) {           closeConnection(bagEntry,\"(connection evicted or dead)\");           timeout=hardTimeout - elapsedTimeMs(start);         }  else {           metricsContext.setConnectionLastOpen(bagEntry,now);           metricsContext.stop();           return ProxyFactory.getProxyConnection((HikariPool)this,bagEntry,leakTask.start(bagEntry));         }       }  while (timeout > 0L);     }  catch (    InterruptedException e) {       throw new SQLException(\"Interrupted during connection acquisition\",e);     }  finally {       suspendResumeLock.release();     }     logPoolState(\"Timeout failure \");     throw new SQLTimeoutException(String.format(\"Timeout after %dms of waiting for a connection.\",elapsedTimeMs(start)),lastConnectionFailure.getAndSet(null));   }   /**   * Release a connection back to the pool, or permanently close it if it is broken.  * @param bagEntry the PoolBagEntry to release back to the pool  */   public final void releaseConnection(  final PoolBagEntry bagEntry){     metricsTracker.recordConnectionUsage(bagEntry);     if (bagEntry.evicted) {       LOGGER.debug(\"Connection returned to pool {} is broken or evicted.  Closing connection.\",configuration.getPoolName());       closeConnection(bagEntry,\"(connection broken or evicted)\");     }  else {       connectionBag.requite(bagEntry);     }   }   /**   * Shutdown the pool, closing all idle connections and aborting or closing active connections.  * @throws InterruptedException thrown if the thread is interrupted during shutdown  */   public final void shutdown() throws InterruptedException {     if (poolState != POOL_SHUTDOWN) {       poolState=POOL_SHUTDOWN;       LOGGER.info(\"HikariCP pool {} is shutting down.\",configuration.getPoolName());       logPoolState(\"Before shutdown \");       connectionBag.close();       softEvictConnections();       houseKeepingExecutorService.shutdown();       addConnectionExecutor.shutdownNow();       houseKeepingExecutorService.awaitTermination(5L,TimeUnit.SECONDS);       addConnectionExecutor.awaitTermination(5L,TimeUnit.SECONDS);       final ExecutorService assassinExecutor=createThreadPoolExecutor(configuration.getMaximumPoolSize(),\"HikariCP connection assassin\",configuration.getThreadFactory(),new ThreadPoolExecutor.CallerRunsPolicy());       final long start=System.currentTimeMillis();       do {         softEvictConnections();         abortActiveConnections(assassinExecutor);       }  while (getTotalConnections() > 0 && elapsedTimeMs(start) < TimeUnit.SECONDS.toMillis(5));       assassinExecutor.shutdown();       assassinExecutor.awaitTermination(5L,TimeUnit.SECONDS);       closeConnectionExecutor.shutdown();       closeConnectionExecutor.awaitTermination(5L,TimeUnit.SECONDS);       logPoolState(\"After shutdown \");       unregisterMBeans(configuration,this);       metricsTracker.close();     }   }   /**   * Evict a connection from the pool.  * @param proxyConnection the connection to evict  */   public final void evictConnection(  IHikariConnectionProxy proxyConnection){     closeConnection(proxyConnection.getPoolBagEntry(),\"(connection evicted by user)\");   }   /**   * Get the wrapped DataSource.  * @return the wrapped DataSource  */   public final DataSource getDataSource(){     return dataSource;   }   /**   * Get the pool configuration object.  * @return the {@link HikariConfig} for this pool  */   public final HikariConfig getConfiguration(){     return configuration;   }   @Override public String toString(){     return configuration.getPoolName();   }   /**   * {@inheritDoc}   */   @Override public final int getActiveConnections(){     return connectionBag.getCount(STATE_IN_USE);   }   /**   * {@inheritDoc}   */   @Override public final int getIdleConnections(){     return connectionBag.getCount(STATE_NOT_IN_USE);   }   /**   * {@inheritDoc}   */   @Override public final int getTotalConnections(){     return connectionBag.size() - connectionBag.getCount(STATE_REMOVED);   }   /**   * {@inheritDoc}   */   @Override public final int getThreadsAwaitingConnection(){     return connectionBag.getPendingQueue();   }   /**   * {@inheritDoc}   */   @Override public final void suspendPool(){     if (suspendResumeLock == GlobalPoolLock.FAUX_LOCK) {       throw new IllegalStateException(\"Pool \" + configuration.getPoolName() + \" is not suspendable\");     }  else     if (poolState != POOL_SUSPENDED) {       suspendResumeLock.suspend();       poolState=POOL_SUSPENDED;     }   }   /**   * {@inheritDoc}   */   @Override public final void resumePool(){     if (poolState == POOL_SUSPENDED) {       poolState=POOL_RUNNING;       addBagItem();       suspendResumeLock.resume();     }   }   public void setMetricRegistry(  Object metricRegistry){     this.isRecordMetrics=metricRegistry != null;     if (isRecordMetrics) {       this.metricsTracker=new CodaHaleMetricsTracker(this,(MetricRegistry)metricRegistry);     }  else {       this.metricsTracker=new MetricsTracker(this);     }   }   public void setHealthCheckRegistry(  Object healthCheckRegistry){     if (healthCheckRegistry != null) {       CodahaleHealthChecker.registerHealthChecks(this,(HealthCheckRegistry)healthCheckRegistry);     }   }   /**   * {@inheritDoc}   */   @Override public Future<Boolean> addBagItem(){     FutureTask<Boolean> future=new FutureTask<Boolean>(new Runnable(){       public void run(){         long sleepBackoff=200L;         final int minimumIdle=configuration.getMinimumIdle();         final int maxPoolSize=configuration.getMaximumPoolSize();         while (poolState == POOL_RUNNING && totalConnections.get() < maxPoolSize && getIdleConnections() <= minimumIdle && !addConnection()) {           quietlySleep(sleepBackoff);           sleepBackoff=Math.min(connectionTimeout / 2,(long)((double)sleepBackoff * 1.5));         }       }     } ,true);     addConnectionExecutor.execute(future);     return future;   }   /**   * Create and add a single connection to the pool.  */   protected final boolean addConnection(){     if (totalConnections.incrementAndGet() <= configuration.getMaximumPoolSize()) {       Connection connection=null;       try {         connection=(username == null && password == null) ? dataSource.getConnection() : dataSource.getConnection(username,password);         if (isUseJdbc4Validation && !poolUtils.isJdbc4ValidationSupported(connection)) {           throw new SQLException(\"JDBC4 Connection.isValid() method not supported, connection test query must be configured\");         }         final int originalTimeout=poolUtils.getAndSetNetworkTimeout(connection,connectionTimeout);         transactionIsolation=(transactionIsolation < 0 ? connection.getTransactionIsolation() : transactionIsolation);         poolUtils.setupConnection(connection,isAutoCommit,isReadOnly,transactionIsolation,catalog);         connectionCustomizer.customize(connection);         poolUtils.executeSql(connection,configuration.getConnectionInitSql(),isAutoCommit);         poolUtils.setNetworkTimeout(connection,originalTimeout);         connectionBag.add(new PoolBagEntry(connection,this));         lastConnectionFailure.set(null);         return true;       }  catch (      Exception e) {         lastConnectionFailure.set(e);         if (poolState == POOL_RUNNING) {           LOGGER.debug(\"Connection attempt to database {} failed: {}\",configuration.getPoolName(),e.getMessage(),e);         }         poolUtils.quietlyCloseConnection(connection,\"(exception during connection creation)\");       }     }     totalConnections.decrementAndGet();     return false;   }   /**   * Fill pool up from current idle connections (as they are perceived at the point of execution) to minimumIdle connections.  */   protected void fillPool(){     final int connectionsToAdd=configuration.getMinimumIdle() - getIdleConnections();     for (int i=0; i < connectionsToAdd; i++) {       addBagItem();     }     if (connectionsToAdd > 0 && LOGGER.isDebugEnabled()) {       addConnectionExecutor.execute(new Runnable(){         public void run(){           logPoolState(\"After fill \");         }       } );     }   }   /**   * Permanently close the real (underlying) connection (eat any exception).  * @param connectionProxy the connection to actually close  */   protected abstract void closeConnection(  final PoolBagEntry bagEntry,  final String closureReason);   /**   * Check whether the connection is alive or not.  * @param connection the connection to test  * @return true if the connection is alive, false if it is not alive or we timed out  */   protected abstract boolean isConnectionAlive(  final Connection connection);   /**   * Attempt to abort() active connections on Java7+, or close() them on Java6.  * @param assassinExecutor   * @throws InterruptedException   */   protected abstract void abortActiveConnections(  final ExecutorService assassinExecutor) throws InterruptedException ;   /**   * Create the JVM version-specific ConcurrentBag instance used by the pool.  * @param listener the IBagStateListener instance  * @return a ConcurrentBag instance  */   protected abstract ConcurrentBag<PoolBagEntry> createConcurrentBag(  IBagStateListener listener);   /**   * Create the JVM version-specific Housekeeping runnable instance used by the pool.  * @return the HouseKeeper instance  */   protected abstract Runnable getHouseKeeper();   /**   * Fill the pool up to the minimum size.  */   private void initializeConnections(){     if (configuration.isInitializationFailFast()) {       try {         try {           if (!addConnection()) {             shutdown();             throw new PoolInitializationException(lastConnectionFailure.getAndSet(null));           }           ConnectionProxy connection=(ConnectionProxy)getConnection();           connection.getPoolBagEntry().evicted=(configuration.getMinimumIdle() == 0);           connection.close();         }  catch (        SQLException e) {           shutdown();           throw new PoolInitializationException(e);         }       }  catch (      InterruptedException ie) {         throw new PoolInitializationException(ie);       }     }     fillPool();   }   /**   * Construct the user's connection customizer, if specified.  * @return an IConnectionCustomizer instance  */   @SuppressWarnings(\"deprecation\") private IConnectionCustomizer initializeCustomizer(){     if (configuration.getConnectionCustomizerClassName() != null) {       return createInstance(configuration.getConnectionCustomizerClassName(),IConnectionCustomizer.class);     }     return configuration.getConnectionCustomizer();   }   public final void logPoolState(  String... prefix){     if (LOGGER.isDebugEnabled()) {       LOGGER.debug(\"{}pool stats {} (total={}, inUse={}, avail={}, waiting={})\",(prefix.length > 0 ? prefix[0] : \"\"),configuration.getPoolName(),getTotalConnections(),getActiveConnections(),getIdleConnections(),getThreadsAwaitingConnection());     }   } } "}, {"bugType": "CHANGE_IDENTIFIER", "fixCommitSHA1": "cf2a9d3aefba1c7d6d4ad399e762edf7a6f6e111", "fixCommitParentSHA1": "1eae36cf1d26c8cb8648a54a45cf4d9d4e3ba504", "bugFilePath": "src/main/java/com/zaxxer/hikari/pool/PoolElf.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/pool/PoolElf.java b/src/main/java/com/zaxxer/hikari/pool/PoolElf.java\nindex afb031e..cb5d25e 100644\n--- a/src/main/java/com/zaxxer/hikari/pool/PoolElf.java\n+++ b/src/main/java/com/zaxxer/hikari/pool/PoolElf.java\n@@ -202,7 +202,7 @@\n             return connection.isValid(timeoutSec);\n          }\n    \n-         networkTimeout = getAndSetNetworkTimeout(connection, validationTimeout);\n+         final int originalTimeout = getAndSetNetworkTimeout(connection, validationTimeout);\n    \n          try (Statement statement = connection.createStatement()) {\n             setQueryTimeout(statement, timeoutSec);\n@@ -215,7 +215,7 @@\n             connection.rollback();\n          }\n    \n-         setNetworkTimeout(connection, networkTimeout);\n+         setNetworkTimeout(connection, originalTimeout);\n    \n          return true;\n       }\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 218, "bugNodeStartChar": 7591, "bugNodeLength": 45, "fixLineNum": 218, "fixNodeStartChar": 7591, "fixNodeLength": 46, "sourceBeforeFix": "setNetworkTimeout(connection,networkTimeout)", "sourceAfterFix": "setNetworkTimeout(connection,originalTimeout)"}, {"bugType": "OVERLOAD_METHOD_MORE_ARGS", "fixCommitSHA1": "cb50434e73c2a60893be26fa49109e759df834f6", "fixCommitParentSHA1": "afc13ee150119209023727ad3d69ce15d2354df3", "bugFilePath": "src/test/java/com/zaxxer/hikari/TestConcurrentBag.java", "fixPatch": "diff --git a/src/test/java/com/zaxxer/hikari/TestConcurrentBag.java b/src/test/java/com/zaxxer/hikari/TestConcurrentBag.java\nindex a943487..397dc08 100644\n--- a/src/test/java/com/zaxxer/hikari/TestConcurrentBag.java\n+++ b/src/test/java/com/zaxxer/hikari/TestConcurrentBag.java\n@@ -103,15 +103,15 @@\n       Assert.assertEquals(0, bag.values(8).size());\n \n       HikariPool pool = TestElf.getPool(ds);\n-      PoolBagEntry reserved = new PoolBagEntry(null, TestElf.getPool(ds));\n+      PoolBagEntry reserved = new PoolBagEntry(null, 0, TestElf.getPool(ds));\n       bag.add(reserved);\n       bag.reserve(reserved);      // reserved\n \n-      PoolBagEntry inuse = new PoolBagEntry(null, pool);\n+      PoolBagEntry inuse = new PoolBagEntry(null, 0, pool);\n       bag.add(inuse);\n       bag.borrow(2, TimeUnit.MILLISECONDS); // in use\n       \n-      PoolBagEntry notinuse = new PoolBagEntry(null, pool);\n+      PoolBagEntry notinuse = new PoolBagEntry(null, 0, pool);\n       bag.add(notinuse); // not in use\n \n       bag.dumpState();\n@@ -135,7 +135,7 @@\n \n       bag.close();\n       try {\n-         PoolBagEntry bagEntry = new PoolBagEntry(null, pool);\n+         PoolBagEntry bagEntry = new PoolBagEntry(null, 0, pool);\n          bag.add(bagEntry);\n          Assert.assertNotEquals(bagEntry, bag.borrow(100, TimeUnit.MILLISECONDS));\n       }\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 106, "bugNodeStartChar": 3074, "bugNodeLength": 43, "fixLineNum": 106, "fixNodeStartChar": 3074, "fixNodeLength": 46, "sourceBeforeFix": "new PoolBagEntry(null,TestElf.getPool(ds))", "sourceAfterFix": "new PoolBagEntry(null,0,TestElf.getPool(ds))"}, {"bugType": "OVERLOAD_METHOD_MORE_ARGS", "fixCommitSHA1": "cb50434e73c2a60893be26fa49109e759df834f6", "fixCommitParentSHA1": "afc13ee150119209023727ad3d69ce15d2354df3", "bugFilePath": "src/test/java/com/zaxxer/hikari/TestConcurrentBag.java", "fixPatch": "diff --git a/src/test/java/com/zaxxer/hikari/TestConcurrentBag.java b/src/test/java/com/zaxxer/hikari/TestConcurrentBag.java\nindex a943487..397dc08 100644\n--- a/src/test/java/com/zaxxer/hikari/TestConcurrentBag.java\n+++ b/src/test/java/com/zaxxer/hikari/TestConcurrentBag.java\n@@ -103,15 +103,15 @@\n       Assert.assertEquals(0, bag.values(8).size());\n \n       HikariPool pool = TestElf.getPool(ds);\n-      PoolBagEntry reserved = new PoolBagEntry(null, TestElf.getPool(ds));\n+      PoolBagEntry reserved = new PoolBagEntry(null, 0, TestElf.getPool(ds));\n       bag.add(reserved);\n       bag.reserve(reserved);      // reserved\n \n-      PoolBagEntry inuse = new PoolBagEntry(null, pool);\n+      PoolBagEntry inuse = new PoolBagEntry(null, 0, pool);\n       bag.add(inuse);\n       bag.borrow(2, TimeUnit.MILLISECONDS); // in use\n       \n-      PoolBagEntry notinuse = new PoolBagEntry(null, pool);\n+      PoolBagEntry notinuse = new PoolBagEntry(null, 0, pool);\n       bag.add(notinuse); // not in use\n \n       bag.dumpState();\n@@ -135,7 +135,7 @@\n \n       bag.close();\n       try {\n-         PoolBagEntry bagEntry = new PoolBagEntry(null, pool);\n+         PoolBagEntry bagEntry = new PoolBagEntry(null, 0, pool);\n          bag.add(bagEntry);\n          Assert.assertNotEquals(bagEntry, bag.borrow(100, TimeUnit.MILLISECONDS));\n       }\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 110, "bugNodeStartChar": 3218, "bugNodeLength": 28, "fixLineNum": 110, "fixNodeStartChar": 3218, "fixNodeLength": 31, "sourceBeforeFix": "new PoolBagEntry(null,pool)", "sourceAfterFix": "new PoolBagEntry(null,0,pool)"}, {"bugType": "OVERLOAD_METHOD_MORE_ARGS", "fixCommitSHA1": "cb50434e73c2a60893be26fa49109e759df834f6", "fixCommitParentSHA1": "afc13ee150119209023727ad3d69ce15d2354df3", "bugFilePath": "src/test/java/com/zaxxer/hikari/TestConcurrentBag.java", "fixPatch": "diff --git a/src/test/java/com/zaxxer/hikari/TestConcurrentBag.java b/src/test/java/com/zaxxer/hikari/TestConcurrentBag.java\nindex a943487..397dc08 100644\n--- a/src/test/java/com/zaxxer/hikari/TestConcurrentBag.java\n+++ b/src/test/java/com/zaxxer/hikari/TestConcurrentBag.java\n@@ -103,15 +103,15 @@\n       Assert.assertEquals(0, bag.values(8).size());\n \n       HikariPool pool = TestElf.getPool(ds);\n-      PoolBagEntry reserved = new PoolBagEntry(null, TestElf.getPool(ds));\n+      PoolBagEntry reserved = new PoolBagEntry(null, 0, TestElf.getPool(ds));\n       bag.add(reserved);\n       bag.reserve(reserved);      // reserved\n \n-      PoolBagEntry inuse = new PoolBagEntry(null, pool);\n+      PoolBagEntry inuse = new PoolBagEntry(null, 0, pool);\n       bag.add(inuse);\n       bag.borrow(2, TimeUnit.MILLISECONDS); // in use\n       \n-      PoolBagEntry notinuse = new PoolBagEntry(null, pool);\n+      PoolBagEntry notinuse = new PoolBagEntry(null, 0, pool);\n       bag.add(notinuse); // not in use\n \n       bag.dumpState();\n@@ -135,7 +135,7 @@\n \n       bag.close();\n       try {\n-         PoolBagEntry bagEntry = new PoolBagEntry(null, pool);\n+         PoolBagEntry bagEntry = new PoolBagEntry(null, 0, pool);\n          bag.add(bagEntry);\n          Assert.assertNotEquals(bagEntry, bag.borrow(100, TimeUnit.MILLISECONDS));\n       }\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 114, "bugNodeStartChar": 3361, "bugNodeLength": 28, "fixLineNum": 114, "fixNodeStartChar": 3361, "fixNodeLength": 31, "sourceBeforeFix": "new PoolBagEntry(null,pool)", "sourceAfterFix": "new PoolBagEntry(null,0,pool)"}, {"bugType": "OVERLOAD_METHOD_MORE_ARGS", "fixCommitSHA1": "cb50434e73c2a60893be26fa49109e759df834f6", "fixCommitParentSHA1": "afc13ee150119209023727ad3d69ce15d2354df3", "bugFilePath": "src/test/java/com/zaxxer/hikari/TestConcurrentBag.java", "fixPatch": "diff --git a/src/test/java/com/zaxxer/hikari/TestConcurrentBag.java b/src/test/java/com/zaxxer/hikari/TestConcurrentBag.java\nindex a943487..397dc08 100644\n--- a/src/test/java/com/zaxxer/hikari/TestConcurrentBag.java\n+++ b/src/test/java/com/zaxxer/hikari/TestConcurrentBag.java\n@@ -103,15 +103,15 @@\n       Assert.assertEquals(0, bag.values(8).size());\n \n       HikariPool pool = TestElf.getPool(ds);\n-      PoolBagEntry reserved = new PoolBagEntry(null, TestElf.getPool(ds));\n+      PoolBagEntry reserved = new PoolBagEntry(null, 0, TestElf.getPool(ds));\n       bag.add(reserved);\n       bag.reserve(reserved);      // reserved\n \n-      PoolBagEntry inuse = new PoolBagEntry(null, pool);\n+      PoolBagEntry inuse = new PoolBagEntry(null, 0, pool);\n       bag.add(inuse);\n       bag.borrow(2, TimeUnit.MILLISECONDS); // in use\n       \n-      PoolBagEntry notinuse = new PoolBagEntry(null, pool);\n+      PoolBagEntry notinuse = new PoolBagEntry(null, 0, pool);\n       bag.add(notinuse); // not in use\n \n       bag.dumpState();\n@@ -135,7 +135,7 @@\n \n       bag.close();\n       try {\n-         PoolBagEntry bagEntry = new PoolBagEntry(null, pool);\n+         PoolBagEntry bagEntry = new PoolBagEntry(null, 0, pool);\n          bag.add(bagEntry);\n          Assert.assertNotEquals(bagEntry, bag.borrow(100, TimeUnit.MILLISECONDS));\n       }\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 138, "bugNodeStartChar": 4203, "bugNodeLength": 28, "fixLineNum": 138, "fixNodeStartChar": 4203, "fixNodeLength": 31, "sourceBeforeFix": "new PoolBagEntry(null,pool)", "sourceAfterFix": "new PoolBagEntry(null,0,pool)"}, {"bugType": "CHANGE_OPERATOR", "fixCommitSHA1": "67b2f81aec955a5ba6faa505da0c5298e78e1e6e", "fixCommitParentSHA1": "ef57e116a79af9246afc42f267a1c89d47231a2c", "bugFilePath": "src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java b/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java\nindex 7f6c825..42985e0 100644\n--- a/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java\n+++ b/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java\n@@ -115,7 +115,7 @@\n \n          for (int i = list.size() - 1; i >= 0; i--) {\n             final T bagEntry = (T) (weakThreadLocals ? ((WeakReference) list.remove(i)).get() : list.remove(i));\n-            if (bagEntry != null & bagEntry.state().compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) {\n+            if (bagEntry != null && bagEntry.state().compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) {\n                return bagEntry;\n             }\n          }\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 118, "bugNodeStartChar": 4656, "bugNodeLength": 81, "fixLineNum": 118, "fixNodeStartChar": 4656, "fixNodeLength": 82, "sourceBeforeFix": "bagEntry != null & bagEntry.state().compareAndSet(STATE_NOT_IN_USE,STATE_IN_USE)", "sourceAfterFix": "bagEntry != null && bagEntry.state().compareAndSet(STATE_NOT_IN_USE,STATE_IN_USE)"}, {"bugType": "DIFFERENT_METHOD_SAME_ARGS", "fixCommitSHA1": "ef43827a7b481bc19b5d738a4c94b62294293eea", "fixCommitParentSHA1": "ccdeeb0746d1a3026f41c0d02263f304e5d51f56", "bugFilePath": "src/main/java/com/zaxxer/hikari/pool/HikariPool.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/pool/HikariPool.java b/src/main/java/com/zaxxer/hikari/pool/HikariPool.java\nindex 8d0bf25..0faad17 100644\n--- a/src/main/java/com/zaxxer/hikari/pool/HikariPool.java\n+++ b/src/main/java/com/zaxxer/hikari/pool/HikariPool.java\n@@ -258,7 +258,7 @@\n                softEvictConnections();\n                abortActiveConnections(assassinExecutor);\n             }\n-            while (getTotalConnections() > 0 && elapsedTimeMs(start) < TimeUnit.SECONDS.toNanos(5));\n+            while (getTotalConnections() > 0 && elapsedTimeMs(start) < TimeUnit.SECONDS.toMillis(5));\n          } finally {\n             assassinExecutor.shutdown();\n             assassinExecutor.awaitTermination(5L, TimeUnit.SECONDS);\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 261, "bugNodeStartChar": 11401, "bugNodeLength": 27, "fixLineNum": 261, "fixNodeStartChar": 11401, "fixNodeLength": 28, "sourceBeforeFix": "TimeUnit.SECONDS.toNanos(5)", "sourceAfterFix": "TimeUnit.SECONDS.toMillis(5)"}, {"bugType": "CHANGE_IDENTIFIER", "fixCommitSHA1": "ef43827a7b481bc19b5d738a4c94b62294293eea", "fixCommitParentSHA1": "ccdeeb0746d1a3026f41c0d02263f304e5d51f56", "bugFilePath": "src/main/java/com/zaxxer/hikari/pool/HikariPool.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/pool/HikariPool.java b/src/main/java/com/zaxxer/hikari/pool/HikariPool.java\nindex 8d0bf25..0faad17 100644\n--- a/src/main/java/com/zaxxer/hikari/pool/HikariPool.java\n+++ b/src/main/java/com/zaxxer/hikari/pool/HikariPool.java\n@@ -258,7 +258,7 @@\n                softEvictConnections();\n                abortActiveConnections(assassinExecutor);\n             }\n-            while (getTotalConnections() > 0 && elapsedTimeMs(start) < TimeUnit.SECONDS.toNanos(5));\n+            while (getTotalConnections() > 0 && elapsedTimeMs(start) < TimeUnit.SECONDS.toMillis(5));\n          } finally {\n             assassinExecutor.shutdown();\n             assassinExecutor.awaitTermination(5L, TimeUnit.SECONDS);\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 261, "bugNodeStartChar": 11401, "bugNodeLength": 27, "fixLineNum": 261, "fixNodeStartChar": 11401, "fixNodeLength": 28, "sourceBeforeFix": "TimeUnit.SECONDS.toNanos(5)", "sourceAfterFix": "TimeUnit.SECONDS.toMillis(5)"}, {"bugType": "CHANGE_OPERATOR", "fixCommitSHA1": "4a1a7785fe4b809277faafb9b7dd65a7ecec62fa", "fixCommitParentSHA1": "084b2ae787d729cd0343fd884ca2d65baa45cd1e", "bugFilePath": "src/main/java/com/zaxxer/hikari/pool/HikariPool.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/pool/HikariPool.java b/src/main/java/com/zaxxer/hikari/pool/HikariPool.java\nindex 02598fe..7fb48dc 100644\n--- a/src/main/java/com/zaxxer/hikari/pool/HikariPool.java\n+++ b/src/main/java/com/zaxxer/hikari/pool/HikariPool.java\n@@ -425,7 +425,7 @@\n    protected final boolean addConnection()\n    {\n       // Speculative increment of totalConnections with expectation of success\n-      if (totalConnections.incrementAndGet() <= configuration.getMaximumPoolSize()) {\n+      if (totalConnections.incrementAndGet() > configuration.getMaximumPoolSize()) {\n          totalConnections.decrementAndGet(); // Pool is maxed out, so undo speculative increment of totalConnections\n          lastConnectionFailure.set(new SQLException(String.format(\"HikariCP pool %s is at maximum capacity\", configuration.getPoolName())));\n          return true;\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 428, "bugNodeStartChar": 16164, "bugNodeLength": 72, "fixLineNum": 428, "fixNodeStartChar": 16164, "fixNodeLength": 71, "sourceBeforeFix": "totalConnections.incrementAndGet() <= configuration.getMaximumPoolSize()", "sourceAfterFix": "totalConnections.incrementAndGet() > configuration.getMaximumPoolSize()"}, {"bugType": "OVERLOAD_METHOD_MORE_ARGS", "fixCommitSHA1": "885b807ebb32d71fe6e980d9ba08b147b69f72af", "fixCommitParentSHA1": "66b64153e1c501bc95ea95de335510e096b709a9", "bugFilePath": "hikaricp-common/src/main/java/com/zaxxer/hikari/util/LeakTask.java", "fixPatch": "diff --git a/hikaricp-common/src/main/java/com/zaxxer/hikari/util/LeakTask.java b/hikaricp-common/src/main/java/com/zaxxer/hikari/util/LeakTask.java\nindex 372e3cd..9b886b0 100644\n--- a/hikaricp-common/src/main/java/com/zaxxer/hikari/util/LeakTask.java\n+++ b/hikaricp-common/src/main/java/com/zaxxer/hikari/util/LeakTask.java\n@@ -65,7 +65,7 @@\n    \n    private LeakTask(final LeakTask parent)\n    {\n-      exception = new Exception();\n+      exception = new Exception(\"Apparent connection leak detected\");\n       scheduledFuture = parent.executorService.schedule(this, parent.leakDetectionThreshold, TimeUnit.MILLISECONDS);\n    }\n \n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 68, "bugNodeStartChar": 1910, "bugNodeLength": 15, "fixLineNum": 68, "fixNodeStartChar": 1910, "fixNodeLength": 50, "sourceBeforeFix": "new Exception()", "sourceAfterFix": "new Exception(\"Apparent connection leak detected\")"}, {"bugType": "CHANGE_NUMERAL", "fixCommitSHA1": "ea3eb38533e342e381416cf0ac0ced45cfb28c92", "fixCommitParentSHA1": "6fd7b8a2c8bd32874b91579be71301538bdff576", "bugFilePath": "hikaricp-common/src/test/java/com/zaxxer/hikari/TestValidation.java", "fixPatch": "diff --git a/hikaricp-common/src/test/java/com/zaxxer/hikari/TestValidation.java b/hikaricp-common/src/test/java/com/zaxxer/hikari/TestValidation.java\nindex e92ad1a..0924a11 100644\n--- a/hikaricp-common/src/test/java/com/zaxxer/hikari/TestValidation.java\n+++ b/hikaricp-common/src/test/java/com/zaxxer/hikari/TestValidation.java\n@@ -170,9 +170,9 @@\n \n       HikariConfig config = new HikariConfig();\n       config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n-      config.setIdleTimeout(TimeUnit.SECONDS.toMillis(25));\n+      config.setIdleTimeout(TimeUnit.SECONDS.toMillis(5));\n       config.validate();\n-      Assert.assertTrue(new String(baos.toByteArray()).contains(\"less than 30000ms\"));\n+      Assert.assertTrue(new String(baos.toByteArray()).contains(\"less than 10000ms\"));\n    }\n \n    @Test\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 173, "bugNodeStartChar": 4954, "bugNodeLength": 29, "fixLineNum": 173, "fixNodeStartChar": 4954, "fixNodeLength": 28, "sourceBeforeFix": "TimeUnit.SECONDS.toMillis(25)", "sourceAfterFix": "TimeUnit.SECONDS.toMillis(5)"}, {"bugType": "CHANGE_MODIFIER", "fixCommitSHA1": "898206f81cbb4ead0fc0f2cf60125d6fd8255ccc", "fixCommitParentSHA1": "949fcb2e43fed93965daef365bf3d3a0d97c907e", "bugFilePath": "hikaricp-common/src/main/java/com/zaxxer/hikari/AbstractHikariConfig.java", "fixPatch": "diff --git a/hikaricp-common/src/main/java/com/zaxxer/hikari/AbstractHikariConfig.java b/hikaricp-common/src/main/java/com/zaxxer/hikari/AbstractHikariConfig.java\nindex a7819ba..44fe4b5 100644\n--- a/hikaricp-common/src/main/java/com/zaxxer/hikari/AbstractHikariConfig.java\n+++ b/hikaricp-common/src/main/java/com/zaxxer/hikari/AbstractHikariConfig.java\n@@ -759,7 +759,7 @@\n \n    abstract protected void loadProperties(String propertyFileName);\n \n-   void copyState(AbstractHikariConfig other)\n+   public void copyState(AbstractHikariConfig other)\n    {\n       for (Field field : AbstractHikariConfig.class.getDeclaredFields()) {\n          if (!Modifier.isFinal(field.getModifiers())) {\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 762, "bugNodeStartChar": 21797, "bugNodeLength": 476, "fixLineNum": 762, "fixNodeStartChar": 21797, "fixNodeLength": 483, "sourceBeforeFix": "0", "sourceAfterFix": "1"}, {"bugType": "CHANGE_NUMERAL", "fixCommitSHA1": "29629e54682850aeca789d11e9a73d5be9248236", "fixCommitParentSHA1": "24995e3cba3ed304c71ef93b22046f8e87f4fa5d", "bugFilePath": "hikaricp-java6/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java", "fixPatch": "diff --git a/hikaricp-java6/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java b/hikaricp-java6/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java\nindex 4325a72..3662a8d 100644\n--- a/hikaricp-java6/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java\n+++ b/hikaricp-java6/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java\n@@ -235,7 +235,7 @@\n          Connection connection6 = ds.getConnection();\n          Connection connection7 = ds.getConnection();\n \n-         Thread.sleep(1350);\n+         Thread.sleep(1500);\n \n          Assert.assertSame(\"Totals connections not as expected\", 10, TestElf.getPool(ds).getTotalConnections());\n          Assert.assertSame(\"Idle connections not as expected\", 3, TestElf.getPool(ds).getIdleConnections());\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 238, "bugNodeStartChar": 7900, "bugNodeLength": 18, "fixLineNum": 238, "fixNodeStartChar": 7900, "fixNodeLength": 18, "sourceBeforeFix": "Thread.sleep(1350)", "sourceAfterFix": "Thread.sleep(1500)"}, {"bugType": "CHANGE_NUMERAL", "fixCommitSHA1": "29629e54682850aeca789d11e9a73d5be9248236", "fixCommitParentSHA1": "24995e3cba3ed304c71ef93b22046f8e87f4fa5d", "bugFilePath": "hikaricp/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java", "fixPatch": "diff --git a/hikaricp/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java b/hikaricp/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java\nindex 4325a72..3662a8d 100644\n--- a/hikaricp/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java\n+++ b/hikaricp/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java\n@@ -235,7 +235,7 @@\n          Connection connection6 = ds.getConnection();\n          Connection connection7 = ds.getConnection();\n \n-         Thread.sleep(1350);\n+         Thread.sleep(1500);\n \n          Assert.assertSame(\"Totals connections not as expected\", 10, TestElf.getPool(ds).getTotalConnections());\n          Assert.assertSame(\"Idle connections not as expected\", 3, TestElf.getPool(ds).getIdleConnections());\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 238, "bugNodeStartChar": 7900, "bugNodeLength": 18, "fixLineNum": 238, "fixNodeStartChar": 7900, "fixNodeLength": 18, "sourceBeforeFix": "Thread.sleep(1350)", "sourceAfterFix": "Thread.sleep(1500)"}, {"bugType": "DIFFERENT_METHOD_SAME_ARGS", "fixCommitSHA1": "48e0acb98213234b32dd4c21eb5a7d4d94e25ca2", "fixCommitParentSHA1": "4c0c9711e13db8ad72f86093461fee7a12451ee6", "bugFilePath": "hikaricp-java6/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java", "fixPatch": "diff --git a/hikaricp-java6/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java b/hikaricp-java6/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java\nindex 7a92155..7129393 100644\n--- a/hikaricp-java6/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java\n+++ b/hikaricp-java6/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java\n@@ -326,7 +326,7 @@\n    {\n       if (connectionTimeout != Integer.MAX_VALUE) {\n          try {\n-            dataSource.setLoginTimeout((int) TimeUnit.MILLISECONDS.toSeconds(Math.min(1000L, connectionTimeout)));\n+            dataSource.setLoginTimeout((int) TimeUnit.MILLISECONDS.toSeconds(Math.max(1000L, connectionTimeout)));\n          }\n          catch (SQLException e) {\n             logger.warn(\"Unable to set DataSource login timeout\", e);\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 329, "bugNodeStartChar": 10653, "bugNodeLength": 34, "fixLineNum": 329, "fixNodeStartChar": 10653, "fixNodeLength": 34, "sourceBeforeFix": "Math.min(1000L,connectionTimeout)", "sourceAfterFix": "Math.max(1000L,connectionTimeout)"}, {"bugType": "CHANGE_IDENTIFIER", "fixCommitSHA1": "48e0acb98213234b32dd4c21eb5a7d4d94e25ca2", "fixCommitParentSHA1": "4c0c9711e13db8ad72f86093461fee7a12451ee6", "bugFilePath": "hikaricp-java6/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java", "fixPatch": "diff --git a/hikaricp-java6/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java b/hikaricp-java6/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java\nindex 7a92155..7129393 100644\n--- a/hikaricp-java6/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java\n+++ b/hikaricp-java6/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java\n@@ -326,7 +326,7 @@\n    {\n       if (connectionTimeout != Integer.MAX_VALUE) {\n          try {\n-            dataSource.setLoginTimeout((int) TimeUnit.MILLISECONDS.toSeconds(Math.min(1000L, connectionTimeout)));\n+            dataSource.setLoginTimeout((int) TimeUnit.MILLISECONDS.toSeconds(Math.max(1000L, connectionTimeout)));\n          }\n          catch (SQLException e) {\n             logger.warn(\"Unable to set DataSource login timeout\", e);\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 329, "bugNodeStartChar": 10653, "bugNodeLength": 34, "fixLineNum": 329, "fixNodeStartChar": 10653, "fixNodeLength": 34, "sourceBeforeFix": "Math.min(1000L,connectionTimeout)", "sourceAfterFix": "Math.max(1000L,connectionTimeout)"}, {"bugType": "DIFFERENT_METHOD_SAME_ARGS", "fixCommitSHA1": "48e0acb98213234b32dd4c21eb5a7d4d94e25ca2", "fixCommitParentSHA1": "4c0c9711e13db8ad72f86093461fee7a12451ee6", "bugFilePath": "hikaricp/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java", "fixPatch": "diff --git a/hikaricp/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java b/hikaricp/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java\nindex 4e4cfaf..32d79f0 100644\n--- a/hikaricp/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java\n+++ b/hikaricp/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java\n@@ -290,7 +290,7 @@\n    {\n       if (connectionTimeout != Integer.MAX_VALUE) {\n          try {\n-            dataSource.setLoginTimeout((int) TimeUnit.MILLISECONDS.toSeconds(Math.min(1000L, connectionTimeout)));\n+            dataSource.setLoginTimeout((int) TimeUnit.MILLISECONDS.toSeconds(Math.max(1000L, connectionTimeout)));\n          }\n          catch (SQLException e) {\n             logger.warn(\"Unable to set DataSource login timeout\", e);\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 293, "bugNodeStartChar": 9855, "bugNodeLength": 34, "fixLineNum": 293, "fixNodeStartChar": 9855, "fixNodeLength": 34, "sourceBeforeFix": "Math.min(1000L,connectionTimeout)", "sourceAfterFix": "Math.max(1000L,connectionTimeout)"}, {"bugType": "CHANGE_IDENTIFIER", "fixCommitSHA1": "48e0acb98213234b32dd4c21eb5a7d4d94e25ca2", "fixCommitParentSHA1": "4c0c9711e13db8ad72f86093461fee7a12451ee6", "bugFilePath": "hikaricp/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java", "fixPatch": "diff --git a/hikaricp/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java b/hikaricp/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java\nindex 4e4cfaf..32d79f0 100644\n--- a/hikaricp/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java\n+++ b/hikaricp/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java\n@@ -290,7 +290,7 @@\n    {\n       if (connectionTimeout != Integer.MAX_VALUE) {\n          try {\n-            dataSource.setLoginTimeout((int) TimeUnit.MILLISECONDS.toSeconds(Math.min(1000L, connectionTimeout)));\n+            dataSource.setLoginTimeout((int) TimeUnit.MILLISECONDS.toSeconds(Math.max(1000L, connectionTimeout)));\n          }\n          catch (SQLException e) {\n             logger.warn(\"Unable to set DataSource login timeout\", e);\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 293, "bugNodeStartChar": 9855, "bugNodeLength": 34, "fixLineNum": 293, "fixNodeStartChar": 9855, "fixNodeLength": 34, "sourceBeforeFix": "Math.min(1000L,connectionTimeout)", "sourceAfterFix": "Math.max(1000L,connectionTimeout)"}, {"bugType": "CHANGE_NUMERAL", "fixCommitSHA1": "8f24815a4a794c1d01bc65696ddc4628a82be322", "fixCommitParentSHA1": "681a7e515fa7dc23bc01940402765adde0fabc77", "bugFilePath": "hikaricp-java6/src/test/java/com/zaxxer/hikari/MiscTest.java", "fixPatch": "diff --git a/hikaricp-java6/src/test/java/com/zaxxer/hikari/MiscTest.java b/hikaricp-java6/src/test/java/com/zaxxer/hikari/MiscTest.java\nindex c37198b..8682dc0 100644\n--- a/hikaricp-java6/src/test/java/com/zaxxer/hikari/MiscTest.java\n+++ b/hikaricp-java6/src/test/java/com/zaxxer/hikari/MiscTest.java\n@@ -108,7 +108,7 @@\n          TestElf.setSlf4jTargetStream(LeakTask.class, ps);\n \n          Connection connection = ds.getConnection();\n-         PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(4));\n+         PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(5));\n          ps.close();\n          connection.close();\n          String s = new String(baos.toByteArray());\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 111, "bugNodeStartChar": 3226, "bugNodeLength": 28, "fixLineNum": 111, "fixNodeStartChar": 3226, "fixNodeLength": 28, "sourceBeforeFix": "TimeUnit.SECONDS.toMillis(4)", "sourceAfterFix": "TimeUnit.SECONDS.toMillis(5)"}, {"bugType": "CHANGE_NUMERAL", "fixCommitSHA1": "8f24815a4a794c1d01bc65696ddc4628a82be322", "fixCommitParentSHA1": "681a7e515fa7dc23bc01940402765adde0fabc77", "bugFilePath": "hikaricp/src/test/java/com/zaxxer/hikari/MiscTest.java", "fixPatch": "diff --git a/hikaricp/src/test/java/com/zaxxer/hikari/MiscTest.java b/hikaricp/src/test/java/com/zaxxer/hikari/MiscTest.java\nindex c37198b..8682dc0 100644\n--- a/hikaricp/src/test/java/com/zaxxer/hikari/MiscTest.java\n+++ b/hikaricp/src/test/java/com/zaxxer/hikari/MiscTest.java\n@@ -108,7 +108,7 @@\n          TestElf.setSlf4jTargetStream(LeakTask.class, ps);\n \n          Connection connection = ds.getConnection();\n-         PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(4));\n+         PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(5));\n          ps.close();\n          connection.close();\n          String s = new String(baos.toByteArray());\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 111, "bugNodeStartChar": 3226, "bugNodeLength": 28, "fixLineNum": 111, "fixNodeStartChar": 3226, "fixNodeLength": 28, "sourceBeforeFix": "TimeUnit.SECONDS.toMillis(4)", "sourceAfterFix": "TimeUnit.SECONDS.toMillis(5)"}, {"bugType": "CHANGE_NUMERAL", "fixCommitSHA1": "a9bf05f5e1a198ca52e50bdd9280cf53fdbdc728", "fixCommitParentSHA1": "682826efe5a312724a73d50fb601f4c61dc5a914", "bugFilePath": "hikaricp-java6/src/test/java/com/zaxxer/hikari/MiscTest.java", "fixPatch": "diff --git a/hikaricp-java6/src/test/java/com/zaxxer/hikari/MiscTest.java b/hikaricp-java6/src/test/java/com/zaxxer/hikari/MiscTest.java\nindex de2b4c2..944beae 100644\n--- a/hikaricp-java6/src/test/java/com/zaxxer/hikari/MiscTest.java\n+++ b/hikaricp-java6/src/test/java/com/zaxxer/hikari/MiscTest.java\n@@ -108,7 +108,7 @@\n          TestElf.setSlf4jTargetStream(LeakTask.class, ps);\n \n          Connection connection = ds.getConnection();\n-         PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(3));\n+         PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(4));\n          ps.close();\n          connection.close();\n          String s = new String(baos.toByteArray());\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 111, "bugNodeStartChar": 3226, "bugNodeLength": 28, "fixLineNum": 111, "fixNodeStartChar": 3226, "fixNodeLength": 28, "sourceBeforeFix": "TimeUnit.SECONDS.toMillis(3)", "sourceAfterFix": "TimeUnit.SECONDS.toMillis(4)"}, {"bugType": "CHANGE_NUMERAL", "fixCommitSHA1": "a9bf05f5e1a198ca52e50bdd9280cf53fdbdc728", "fixCommitParentSHA1": "682826efe5a312724a73d50fb601f4c61dc5a914", "bugFilePath": "hikaricp/src/test/java/com/zaxxer/hikari/MiscTest.java", "fixPatch": "diff --git a/hikaricp/src/test/java/com/zaxxer/hikari/MiscTest.java b/hikaricp/src/test/java/com/zaxxer/hikari/MiscTest.java\nindex de2b4c2..944beae 100644\n--- a/hikaricp/src/test/java/com/zaxxer/hikari/MiscTest.java\n+++ b/hikaricp/src/test/java/com/zaxxer/hikari/MiscTest.java\n@@ -108,7 +108,7 @@\n          TestElf.setSlf4jTargetStream(LeakTask.class, ps);\n \n          Connection connection = ds.getConnection();\n-         PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(3));\n+         PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(4));\n          ps.close();\n          connection.close();\n          String s = new String(baos.toByteArray());\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 111, "bugNodeStartChar": 3226, "bugNodeLength": 28, "fixLineNum": 111, "fixNodeStartChar": 3226, "fixNodeLength": 28, "sourceBeforeFix": "TimeUnit.SECONDS.toMillis(3)", "sourceAfterFix": "TimeUnit.SECONDS.toMillis(4)"}, {"bugType": "LESS_SPECIFIC_IF", "fixCommitSHA1": "70c0e3d96ba8a14efb61e375915027b7346ba49f", "fixCommitParentSHA1": "f875f3838c4b454a0fee9923611198962adc9f5b", "bugFilePath": "src/main/java/com/zaxxer/hikari/HikariConfig.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/HikariConfig.java b/src/main/java/com/zaxxer/hikari/HikariConfig.java\nindex 9ade527..3c77a58 100644\n--- a/src/main/java/com/zaxxer/hikari/HikariConfig.java\n+++ b/src/main/java/com/zaxxer/hikari/HikariConfig.java\n@@ -546,7 +546,7 @@\n    @Override\n    public void setMinimumIdle(int minIdle)\n    {\n-      if (minIdle < 0 || minIdle > maxPoolSize) {\n+      if (minIdle < 0) {\n          throw new IllegalArgumentException(\"maxPoolSize cannot be negative or greater than maximumPoolSize\");\n       }\n       this.minIdle = minIdle;\n@@ -696,7 +696,7 @@\n          connectionTimeout = CONNECTION_TIMEOUT;\n       }\n \n-      if (minIdle < 0) {\n+      if (minIdle < 0 || minIdle > maxPoolSize) {\n          minIdle = maxPoolSize;\n       }\n \n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 699, "bugNodeStartChar": 19304, "bugNodeLength": 11, "fixLineNum": 699, "fixNodeStartChar": 19304, "fixNodeLength": 36, "sourceBeforeFix": "minIdle < 0", "sourceAfterFix": "minIdle < 0 || minIdle > maxPoolSize"}, {"bugType": "LESS_SPECIFIC_IF", "fixCommitSHA1": "70c0e3d96ba8a14efb61e375915027b7346ba49f", "fixCommitParentSHA1": "f875f3838c4b454a0fee9923611198962adc9f5b", "bugFilePath": "src/main/java/com/zaxxer/hikari/HikariConfig.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/HikariConfig.java b/src/main/java/com/zaxxer/hikari/HikariConfig.java\nindex 9ade527..3c77a58 100644\n--- a/src/main/java/com/zaxxer/hikari/HikariConfig.java\n+++ b/src/main/java/com/zaxxer/hikari/HikariConfig.java\n@@ -546,7 +546,7 @@\n    @Override\n    public void setMinimumIdle(int minIdle)\n    {\n-      if (minIdle < 0 || minIdle > maxPoolSize) {\n+      if (minIdle < 0) {\n          throw new IllegalArgumentException(\"maxPoolSize cannot be negative or greater than maximumPoolSize\");\n       }\n       this.minIdle = minIdle;\n@@ -696,7 +696,7 @@\n          connectionTimeout = CONNECTION_TIMEOUT;\n       }\n \n-      if (minIdle < 0) {\n+      if (minIdle < 0 || minIdle > maxPoolSize) {\n          minIdle = maxPoolSize;\n       }\n \n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 699, "bugNodeStartChar": 19304, "bugNodeLength": 11, "fixLineNum": 699, "fixNodeStartChar": 19304, "fixNodeLength": 36, "sourceBeforeFix": "minIdle < 0", "sourceAfterFix": "minIdle < 0 || minIdle > maxPoolSize"}, {"bugType": "CHANGE_MODIFIER", "fixCommitSHA1": "3647ec7fe4dd13d25303a82d24af4a2e38e62e4c", "fixCommitParentSHA1": "acb87900777cfe69fe9eb039f987046702bdb540", "bugFilePath": "src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java b/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java\nindex f4e3988..b0e594e 100644\n--- a/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java\n+++ b/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java\n@@ -58,7 +58,7 @@\n     private boolean forceClose;\n     private boolean isAutoCommitDirty;\n     private boolean isCatalogDirty;\n-    private volatile boolean isClosed;\n+    private boolean isClosed;\n     private boolean isReadOnlyDirty;\n     private boolean isTransactionIsolationDirty;\n     private volatile long lastAccess;\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 61, "bugNodeStartChar": 1894, "bugNodeLength": 34, "fixLineNum": 61, "fixNodeStartChar": 1894, "fixNodeLength": 25, "sourceBeforeFix": "66", "sourceAfterFix": "2"}, {"bugType": "CHANGE_MODIFIER", "fixCommitSHA1": "5a1e22b7115658cfcb45ba9c8cbe86b8cd285fae", "fixCommitParentSHA1": "cc12165b44316296049c97dd454d4f160436feec", "bugFilePath": "src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java b/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java\nindex 445328f..ce3034d 100644\n--- a/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java\n+++ b/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java\n@@ -58,7 +58,7 @@\n     private boolean forceClose;\n     private boolean isAutoCommitDirty;\n     private boolean isCatalogDirty;\n-    private boolean isClosed;\n+    private volatile boolean isClosed;\n     private boolean isReadOnlyDirty;\n     private boolean isTransactionIsolationDirty;\n     private volatile long lastAccess;\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 61, "bugNodeStartChar": 1894, "bugNodeLength": 25, "fixLineNum": 61, "fixNodeStartChar": 1894, "fixNodeLength": 34, "sourceBeforeFix": "2", "sourceAfterFix": "66"}, {"bugType": "CHANGE_OPERATOR", "fixCommitSHA1": "4e26f3e2020bfe5fd3271952021be040192d81c6", "fixCommitParentSHA1": "34d5f74e0f6ebcfba39c9cf605b8ff3eaaf6fdc7", "bugFilePath": "src/main/java/com/zaxxer/hikari/HikariDataSource.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/HikariDataSource.java b/src/main/java/com/zaxxer/hikari/HikariDataSource.java\nindex 6bbe7c3..6e8b863 100644\n--- a/src/main/java/com/zaxxer/hikari/HikariDataSource.java\n+++ b/src/main/java/com/zaxxer/hikari/HikariDataSource.java\n@@ -190,7 +190,7 @@\n     @Override\n     public boolean isWrapperFor(Class<?> iface) throws SQLException\n     {\n-        return (pool != null & pool.getDataSource().getClass().isAssignableFrom(iface));\n+        return (pool != null && pool.getDataSource().getClass().isAssignableFrom(iface));\n     }\n \n     /**\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 193, "bugNodeStartChar": 5539, "bugNodeLength": 70, "fixLineNum": 193, "fixNodeStartChar": 5539, "fixNodeLength": 71, "sourceBeforeFix": "pool != null & pool.getDataSource().getClass().isAssignableFrom(iface)", "sourceAfterFix": "pool != null && pool.getDataSource().getClass().isAssignableFrom(iface)"}, {"bugType": "CHANGE_OPERATOR", "fixCommitSHA1": "079bf9e8c2d461012d7c403081c5f9cf29372d28", "fixCommitParentSHA1": "bcfcf71721de8376145c43020a8da2986e3dac8a", "bugFilePath": "src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java", "fixPatch": "diff --git a/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java b/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java\nindex e3d67cb..d92d362 100644\n--- a/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java\n+++ b/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java\n@@ -185,7 +185,7 @@\n         catch (SQLException e)\n         {\n             long elapsed = System.currentTimeMillis() - start;\n-            Assert.assertTrue(\"Didn't wait long enough for timeout\", (elapsed > config.getConnectionTimeout()));\n+            Assert.assertTrue(\"Didn't wait long enough for timeout\", (elapsed >= config.getConnectionTimeout()));\n         }\n         finally\n         {\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 188, "bugNodeStartChar": 6311, "bugNodeLength": 39, "fixLineNum": 188, "fixNodeStartChar": 6311, "fixNodeLength": 40, "sourceBeforeFix": "elapsed > config.getConnectionTimeout()", "sourceAfterFix": "elapsed >= config.getConnectionTimeout()"}, {"bugType": "MORE_SPECIFIC_IF", "fixCommitSHA1": "d8bc2819023c4a23aecb28c3ecab448771e8a3a6", "fixCommitParentSHA1": "2112a3470eb007729ea60ee4b8d743c707389256", "bugFilePath": "src/main/java/com/zaxxer/hikari/HikariPool.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/HikariPool.java b/src/main/java/com/zaxxer/hikari/HikariPool.java\nindex bd338a4..ed93125 100644\n--- a/src/main/java/com/zaxxer/hikari/HikariPool.java\n+++ b/src/main/java/com/zaxxer/hikari/HikariPool.java\n@@ -340,7 +340,7 @@\n             try\n             {\n                 // Speculative increment of totalConnections with expectation of success\n-                if (totalConnections.incrementAndGet() > configuration.getMaximumPoolSize())\n+                if (retries == 0 && totalConnections.incrementAndGet() > configuration.getMaximumPoolSize())\n                 {\n                     totalConnections.decrementAndGet();\n                     break;\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 343, "bugNodeStartChar": 11140, "bugNodeLength": 71, "fixLineNum": 343, "fixNodeStartChar": 11140, "fixNodeLength": 87, "sourceBeforeFix": "totalConnections.incrementAndGet() > configuration.getMaximumPoolSize()", "sourceAfterFix": "retries == 0 && totalConnections.incrementAndGet() > configuration.getMaximumPoolSize()"}, {"bugType": "MORE_SPECIFIC_IF", "fixCommitSHA1": "41df5a6f7ebe103b007a01aa58d400864e09de26", "fixCommitParentSHA1": "944a7c54ecdbf278b7d80053ab6101980c4baadb", "bugFilePath": "core/src/main/java/com/zaxxer/hikari/HikariConfig.java", "fixPatch": "diff --git a/core/src/main/java/com/zaxxer/hikari/HikariConfig.java b/core/src/main/java/com/zaxxer/hikari/HikariConfig.java\nindex f14946b..5bafd77 100644\n--- a/core/src/main/java/com/zaxxer/hikari/HikariConfig.java\n+++ b/core/src/main/java/com/zaxxer/hikari/HikariConfig.java\n@@ -403,7 +403,7 @@\n             logger.error(\"idleTimeout cannot be negative.\");\n             throw new IllegalStateException(\"idleTimeout cannot be negative.\");\n         }\n-        else if (idleTimeout < 30000)\n+        else if (idleTimeout < 30000 && idleTimeout != 0)\n         {\n             logger.warn(\"idleTimeout is less than 30000ms, did you specify the wrong time unit?  Using default instead.\");\n             idleTimeout = IDLE_TIMEOUT;\n@@ -438,7 +438,7 @@\n             logger.error(\"maxLifetime cannot be negative.\");\n             throw new IllegalStateException(\"maxLifetime cannot be negative.\");\n         }\n-        else if (maxLifetime < 120000)\n+        else if (maxLifetime < 120000 && maxLifetime != 0)\n         {\n             logger.warn(\"maxLifetime is less than 120000ms, did you specify the wrong time unit?  Using default instead.\");\n             maxLifetime = MAX_LIFETIME;\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 406, "bugNodeStartChar": 11005, "bugNodeLength": 19, "fixLineNum": 406, "fixNodeStartChar": 11005, "fixNodeLength": 39, "sourceBeforeFix": "idleTimeout < 30000", "sourceAfterFix": "idleTimeout < 30000 && idleTimeout != 0"}, {"bugType": "MORE_SPECIFIC_IF", "fixCommitSHA1": "41df5a6f7ebe103b007a01aa58d400864e09de26", "fixCommitParentSHA1": "944a7c54ecdbf278b7d80053ab6101980c4baadb", "bugFilePath": "core/src/main/java/com/zaxxer/hikari/HikariConfig.java", "fixPatch": "diff --git a/core/src/main/java/com/zaxxer/hikari/HikariConfig.java b/core/src/main/java/com/zaxxer/hikari/HikariConfig.java\nindex f14946b..5bafd77 100644\n--- a/core/src/main/java/com/zaxxer/hikari/HikariConfig.java\n+++ b/core/src/main/java/com/zaxxer/hikari/HikariConfig.java\n@@ -403,7 +403,7 @@\n             logger.error(\"idleTimeout cannot be negative.\");\n             throw new IllegalStateException(\"idleTimeout cannot be negative.\");\n         }\n-        else if (idleTimeout < 30000)\n+        else if (idleTimeout < 30000 && idleTimeout != 0)\n         {\n             logger.warn(\"idleTimeout is less than 30000ms, did you specify the wrong time unit?  Using default instead.\");\n             idleTimeout = IDLE_TIMEOUT;\n@@ -438,7 +438,7 @@\n             logger.error(\"maxLifetime cannot be negative.\");\n             throw new IllegalStateException(\"maxLifetime cannot be negative.\");\n         }\n-        else if (maxLifetime < 120000)\n+        else if (maxLifetime < 120000 && maxLifetime != 0)\n         {\n             logger.warn(\"maxLifetime is less than 120000ms, did you specify the wrong time unit?  Using default instead.\");\n             maxLifetime = MAX_LIFETIME;\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 441, "bugNodeStartChar": 12405, "bugNodeLength": 20, "fixLineNum": 441, "fixNodeStartChar": 12405, "fixNodeLength": 40, "sourceBeforeFix": "maxLifetime < 120000", "sourceAfterFix": "maxLifetime < 120000 && maxLifetime != 0"}, {"bugType": "CHANGE_NUMERAL", "fixCommitSHA1": "63d67dfa1995b51ffa10fee42e2dc9df5694febb", "fixCommitParentSHA1": "28993fd4395f537a6552a9791b79313b007dd595", "bugFilePath": "src/main/java/com/zaxxer/hikari/HikariPool.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/HikariPool.java b/src/main/java/com/zaxxer/hikari/HikariPool.java\nindex 2d6070b..dd2dbe7 100644\n--- a/src/main/java/com/zaxxer/hikari/HikariPool.java\n+++ b/src/main/java/com/zaxxer/hikari/HikariPool.java\n@@ -334,17 +334,17 @@\n      */\n     private boolean isConnectionAlive(final Connection connection, long timeoutMs)\n     {\n-        // Set a realistic minimum timeout\n-        if (timeoutMs < 500)\n+        // java.sql.Connection.isValid timeout is seconds, and can't be zero for timeout to work\n+        if (timeoutMs < 1000)\n         {\n-            timeoutMs = 500;\n+            timeoutMs = 1000;\n         }\n \n         try\n         {\n             if (jdbc4ConnectionTest)\n             {\n-                return connection.isValid((int) timeoutMs * 1000);\n+                return connection.isValid((int) timeoutMs / 1000);\n             }\n \n             Statement statement = connection.createStatement();\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 338, "bugNodeStartChar": 11356, "bugNodeLength": 15, "fixLineNum": 338, "fixNodeStartChar": 11410, "fixNodeLength": 16, "sourceBeforeFix": "timeoutMs < 500", "sourceAfterFix": "timeoutMs < 1000"}, {"bugType": "CHANGE_NUMERAL", "fixCommitSHA1": "63d67dfa1995b51ffa10fee42e2dc9df5694febb", "fixCommitParentSHA1": "28993fd4395f537a6552a9791b79313b007dd595", "bugFilePath": "src/main/java/com/zaxxer/hikari/HikariPool.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/HikariPool.java b/src/main/java/com/zaxxer/hikari/HikariPool.java\nindex 2d6070b..dd2dbe7 100644\n--- a/src/main/java/com/zaxxer/hikari/HikariPool.java\n+++ b/src/main/java/com/zaxxer/hikari/HikariPool.java\n@@ -334,17 +334,17 @@\n      */\n     private boolean isConnectionAlive(final Connection connection, long timeoutMs)\n     {\n-        // Set a realistic minimum timeout\n-        if (timeoutMs < 500)\n+        // java.sql.Connection.isValid timeout is seconds, and can't be zero for timeout to work\n+        if (timeoutMs < 1000)\n         {\n-            timeoutMs = 500;\n+            timeoutMs = 1000;\n         }\n \n         try\n         {\n             if (jdbc4ConnectionTest)\n             {\n-                return connection.isValid((int) timeoutMs * 1000);\n+                return connection.isValid((int) timeoutMs / 1000);\n             }\n \n             Statement statement = connection.createStatement();\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 340, "bugNodeStartChar": 11395, "bugNodeLength": 15, "fixLineNum": 340, "fixNodeStartChar": 11395, "fixNodeLength": 16, "sourceBeforeFix": "timeoutMs=500", "sourceAfterFix": "timeoutMs=1000"}, {"bugType": "CHANGE_OPERATOR", "fixCommitSHA1": "63d67dfa1995b51ffa10fee42e2dc9df5694febb", "fixCommitParentSHA1": "28993fd4395f537a6552a9791b79313b007dd595", "bugFilePath": "src/main/java/com/zaxxer/hikari/HikariPool.java", "fixPatch": "diff --git a/src/main/java/com/zaxxer/hikari/HikariPool.java b/src/main/java/com/zaxxer/hikari/HikariPool.java\nindex 2d6070b..dd2dbe7 100644\n--- a/src/main/java/com/zaxxer/hikari/HikariPool.java\n+++ b/src/main/java/com/zaxxer/hikari/HikariPool.java\n@@ -334,17 +334,17 @@\n      */\n     private boolean isConnectionAlive(final Connection connection, long timeoutMs)\n     {\n-        // Set a realistic minimum timeout\n-        if (timeoutMs < 500)\n+        // java.sql.Connection.isValid timeout is seconds, and can't be zero for timeout to work\n+        if (timeoutMs < 1000)\n         {\n-            timeoutMs = 500;\n+            timeoutMs = 1000;\n         }\n \n         try\n         {\n             if (jdbc4ConnectionTest)\n             {\n-                return connection.isValid((int) timeoutMs * 1000);\n+                return connection.isValid((int) timeoutMs / 1000);\n             }\n \n             Statement statement = connection.createStatement();\n", "projectName": "brettwooldridge.HikariCP", "bugLineNum": 347, "bugNodeStartChar": 11538, "bugNodeLength": 22, "fixLineNum": 347, "fixNodeStartChar": 11538, "fixNodeLength": 22, "sourceBeforeFix": "(int)timeoutMs * 1000", "sourceAfterFix": "(int)timeoutMs / 1000"}]